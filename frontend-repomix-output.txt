This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
src/
  app/
    api/
      auth/
        [...nextauth]/
          route.ts
          utils.ts
      code/
        status/
          route.ts
        submit/
          route.ts
    login/
      page.tsx
    school/
      [id]/
        cohort/
          [cohortId]/
            leaderboard/
              ClientLeaderboardView.tsx
              page.tsx
        join/
          page.tsx
        ClientSchoolLearnerView.tsx
        page.tsx
      admin/
        [id]/
          cohorts/
            [cohortId]/
              ClientCohortPage.tsx
              page.tsx
          courses/
            [courseId]/
              learner-view/
                [learnerId]/
                  ClientLearnerViewWrapper.tsx
                  page.tsx
              preview/
                ClientPreviewWrapper.tsx
                page.tsx
              page.tsx
          ClientSchoolAdminView.tsx
          page.tsx
        create/
          page.tsx
        layout.tsx
    layout.tsx
    page.tsx
  components/
    layout/
      header.tsx
    ui/
      avatar.tsx
      button.tsx
      card.tsx
      tabs.tsx
    AudioInputComponent.tsx
    BlockNoteEditor.tsx
    ChatHistoryView.tsx
    ChatPlaceholderView.tsx
    ChatView.tsx
    CodeEditorView.tsx
    CohortCard.tsx
    CohortCoursesLinkerDropdown.tsx
    CohortDashboard.tsx
    CohortMemberManagement.tsx
    ConfirmationDialog.tsx
    CourseCard.tsx
    CourseCohortSelectionDialog.tsx
    CourseItemDialog.tsx
    CourseModuleList.tsx
    CoursePublishSuccessBanner.tsx
    CreateCohortDialog.tsx
    CreateCourseDialog.tsx
    DripPublishingConfig.tsx
    Dropdown.tsx
    dropdownOptions.ts
    editor-styles.css
    GenerateWithAIDialog.tsx
    InviteMembersDialog.tsx
    LearnerCohortView.tsx
    LearnerCourseView.tsx
    LearnerQuizView.tsx
    LearnerScorecard.tsx
    LearningMaterialEditor.tsx
    LearningMaterialLinker.tsx
    LearningMaterialViewer.tsx
    LearningStreak.tsx
    MobileDropdown.tsx
    ModuleCompletionSound.tsx
    PublishConfirmationDialog.tsx
    QuizEditor.tsx
    SchoolPickerDialog.tsx
    scorecard-styles.css
    Scorecard.tsx
    ScorecardPickerDialog.tsx
    ScorecardView.tsx
    SettingsDialog.tsx
    SimpleTooltip.tsx
    SuccessSound.tsx
    TaskTypeMetricCard.tsx
    Toast.tsx
    Tooltip.tsx
    TopPerformers.tsx
    UnauthorizedError.tsx
  context/
    EditorContext.tsx
  lib/
    utils/
      dateFormat.ts
      localStorage.ts
    api.ts
    auth.ts
    course.ts
    server-api.ts
    utils.ts
  providers/
    SessionProvider.tsx
  types/
    course.ts
    index.ts
    next-auth.d.ts
    quiz.ts
  index.css
  middleware.ts
.dockerignore
.env.example
.gitignore
.gitlab-ci.yml
.repomixignore
codecov.yml
docker-compose.dev.yml
docker-compose.prod.yml
Dockerfile
empty-module.ts
LICENSE
next.config.ts
package.json
README.md
tailwind.config.js

================================================================
Files
================================================================

================
File: src/app/api/auth/[...nextauth]/route.ts
================
import NextAuth from "next-auth";
import GoogleProvider from "next-auth/providers/google";
import { JWT } from "next-auth/jwt";
import { Session } from "next-auth";
import type { User, Account, Profile } from "next-auth";
import { registerUserWithBackend } from "./utils";
⋮----
async jwt(
⋮----
// If signing in for the first time, save user info in token
⋮----
// If this is a Google signin, get userId from backend
⋮----
// Extract the ID from the result
⋮----
// Store the backend userId directly in the token
⋮----
async session(
⋮----
// Send properties to the client
⋮----
// Use the backend user ID directly as the main ID
⋮----
session.user.id = String(token.userId); // Ensure ID is stored as string
⋮----
// Add access token to session if it exists
⋮----
async signIn(
⋮----
// We no longer need to call registerUserWithBackend here
// since we're now doing it in the jwt callback to store the ID
⋮----
// Still return true to not block the auth flow

================
File: src/app/api/auth/[...nextauth]/utils.ts
================
/**
 * Server-side utility functions for authentication
 */
⋮----
interface UserData {
  email: string;
  given_name?: string;
  family_name?: string;
  name?: string;
  image?: string;
  id?: string;
}
⋮----
interface AccountData {
  access_token?: string;
  id_token?: string;
  provider?: string;
}
⋮----
/**
 * Send user authentication data to the backend after successful Google login
 * This is a server-side implementation for NextAuth callbacks
 */
export async function registerUserWithBackend(
  user: UserData,
  account: AccountData
): Promise<any>
⋮----
// Return the raw response data - assuming it contains an 'id' field directly
⋮----
// Make sure the ID exists and is returned properly
⋮----
// Don't throw error to prevent blocking the auth flow
// Just log it and continue

================
File: src/app/api/code/status/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
⋮----
/**
 * API route to proxy requests to Judge0 API for checking submission status
 * This avoids CORS issues when calling Judge0 directly from the browser
 */
export async function GET(request: NextRequest)
⋮----
// Get the token and Judge0 URL from the query parameters
⋮----
// Forward the request to Judge0
⋮----
// If the response wasn't successful, throw an error
⋮----
// Get the JSON response
⋮----
// Return the data from Judge0

================
File: src/app/api/code/submit/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
⋮----
/**
 * API route to proxy requests to Judge0 API for code submissions
 * This avoids CORS issues when calling Judge0 directly from the browser
 */
export async function POST(request: NextRequest)
⋮----
// Parse the request body
⋮----
// Forward the request to Judge0
⋮----
// If the response wasn't successful, throw an error
⋮----
// Get the JSON response
⋮----
// Return the data from Judge0

================
File: src/app/login/page.tsx
================
import { signIn, useSession } from "next-auth/react";
import Link from "next/link";
import Image from "next/image";
import { useRouter, useSearchParams } from "next/navigation";
import { Suspense, useEffect } from "react";
⋮----
// Create a separate component that uses useSearchParams
⋮----
// Redirect if already authenticated
⋮----
const handleGoogleLogin = () =>
⋮----
// Show loading state while checking session
⋮----
{/* Content */}
⋮----
{/* Main copy - spans 7 columns on desktop */}
⋮----
{/* Logo */}
⋮----
{/* Login card - spans 5 columns on desktop */}
⋮----
<Link href="https://hyperverge.notion.site/SensAI-Privacy-Policy-1627e7c237cb80e5babae67e64642f27" className="text-purple-400 hover:underline">
⋮----
// Main component with Suspense boundary

================
File: src/app/school/[id]/cohort/[cohortId]/leaderboard/ClientLeaderboardView.tsx
================
import React, { useState, useEffect } from "react";
import Image from "next/image";
import { useRouter } from "next/navigation";
import { ArrowLeft } from "lucide-react";
import { useAuth } from "@/lib/auth";
import { Header } from "@/components/layout/header";
import { Performer } from "@/components/TopPerformers";
⋮----
// Fetch leaderboard data
⋮----
const fetchLeaderboardData = async () =>
⋮----
// Transform API response to match Performer interface
⋮----
position: index + 1, // Position based on array order
userId: stat.user.id // Keep track of user ID for identifying current user
⋮----
// Function to get the appropriate badge SVG based on position
const getPositionBadge = (position: number) =>
⋮----
// Check if a performer is the current user
const isCurrentUser = (performer: Performer) =>
⋮----
// Check if performer should show a medal (top 3 position AND streak > 0)
const shouldShowMedal = (performer: Performer) =>
⋮----
{/* Back button and page title */}
⋮----
{/* Mobile back button - visible only on small screens */}
⋮----
{/* Title - different layouts for mobile and desktop */}
⋮----
{/* Desktop: cohort / leaderboard format */}
⋮----
{/* Mobile: only leaderboard title */}
⋮----
{/* Column Headers */}
⋮----
{/* Performers List */}
⋮----
{/* Position Column */}
⋮----
src=
⋮----
{/* Name Column */}
⋮----
{/* Streak Column */}
⋮----
{/* Tasks Solved Column */}

================
File: src/app/school/[id]/cohort/[cohortId]/leaderboard/page.tsx
================
import { Metadata } from 'next';
import ClientLeaderboardView from './ClientLeaderboardView';
import { cookies } from 'next/headers';
⋮----
async function getCohortName(cohortId: string)
⋮----
// Replace with your actual API endpoint
⋮----
export default async function LeaderboardPage({
    params,
}: {
    params: { id: string; cohortId: string };
})
⋮----
// Fetch the cohort name on the server

================
File: src/app/school/[id]/join/page.tsx
================
import { useParams, useRouter, useSearchParams } from "next/navigation";
import { useEffect, useState } from "react";
import { useAuth } from "@/lib/auth";
import { CheckCircle, AlertCircle } from "lucide-react";
import Toast from "@/components/Toast";
⋮----
// Toast state
⋮----
// Wait for auth to be ready
⋮----
// Make sure user is authenticated
⋮----
// Make sure cohortId is present
⋮----
const joinCohort = async () =>
⋮----
// Check for 400 status code (already in cohort)
⋮----
// Show toast for already being in the cohort
⋮----
// Redirect to school page after a short delay
⋮----
// Show toast for being an admin
⋮----
// Redirect to school page after a short delay
⋮----
// Handle other errors
⋮----
// Successfully joined the cohort
⋮----
// Redirect to the school page after a short delay
⋮----
{/* Toast notification */}

================
File: src/app/school/[id]/ClientSchoolLearnerView.tsx
================
import { useState, useEffect } from "react";
import { Header } from "@/components/layout/header";
import { Building, ChevronDown, ChevronLeft, Info } from "lucide-react";
import { useRouter, useSearchParams } from "next/navigation";
import CohortCard from "@/components/CohortCard";
import { useAuth } from "@/lib/auth";
import LearnerCohortView from "@/components/LearnerCohortView";
import { Module, ModuleItem } from "@/types/course";
import { getCompletionData, useSchools } from "@/lib/api";
import { Cohort, Task, Milestone } from "@/types";
import { transformCourseToModules } from "@/lib/course";
import MobileDropdown, { DropdownOption } from "@/components/MobileDropdown";
⋮----
interface School {
    id: number;
    name: string;
    slug: string;
}
⋮----
interface Course {
    id: number;
    name: string;
    milestones?: Milestone[];
    course_generation_status?: string | null;
}
⋮----
// Get course_id and cohort_id from query parameters
⋮----
// Add state for completion data
⋮----
// Fetch school data
⋮----
const fetchSchool = async () =>
⋮----
// Don't fetch if auth is still loading or user is not authenticated
⋮----
// Fetch basic school info using slug
⋮----
// Transform the API response to match the School interface
⋮----
// Check if user is admin or owner of this school
⋮----
// If user is owner or admin, fetch all cohorts for the school
⋮----
// Otherwise, fetch only the cohorts the user is a member of
⋮----
// Transform cohorts data
⋮----
// Set the active cohort based on query parameters if available
⋮----
// Try to find the cohort that matches the cohort_id from query params
⋮----
// If we can't find the cohort, default to the first one
⋮----
// Default behavior - use the first cohort
⋮----
// Function to fetch cohort courses
const fetchCohortCourses = async (cohortId: number) =>
⋮----
// Check if 'joined_at' exists, as older learners may not have this timestamp.
⋮----
// Reset active course index when cohort changes
⋮----
// Transform the first course's milestones to modules if available
⋮----
// Function to fetch completion data
const fetchCompletionData = async (cohortId: number, userId: string) =>
⋮----
// Update state with processed completion data
⋮----
// We don't set an error state as this is not critical functionality
// Just log the error and continue
⋮----
// Fetch courses when active cohort changes
⋮----
// Also fetch completion data when cohort changes
⋮----
// Update to handle course selection from query params after courses are loaded
⋮----
// Find the index of the course that matches the course_id from query params
⋮----
// Set the active course to the one from query params
⋮----
// Handle course tab selection
const handleCourseSelect = (index: number) =>
⋮----
// Update URL with course ID
⋮----
// Replace current URL to avoid adding to browser history stack
⋮----
// Helper function to update URL query params
const updateUrlWithCohortId = (cohortId: number) =>
⋮----
// Create the new URL with updated query parameters
⋮----
// Set cohort id in query params
⋮----
// will later set course id defaults in the query param after course cohorts have loaded
⋮----
// Replace current URL to avoid adding to browser history stack
⋮----
// Keep the original handleCohortSelect function for the Header component
const handleCohortSelect = (cohort: Cohort) =>
⋮----
// Update URL with cohort ID
⋮----
// Transform cohorts to dropdown options
⋮----
// Handle cohort selection from dropdown
const handleCohortOptionSelect = (option: DropdownOption<Cohort>) =>
⋮----
// Update URL with cohort ID
⋮----
// Handle back button click
const handleBackClick = () =>
⋮----
// Show loading state while auth is loading
⋮----
// Redirect to login if not authenticated
⋮----
// Use client-side redirect
⋮----
{/* Admin/Owner Banner */}
⋮----
{/* Mobile Cohort Banner - Always show on mobile */}
⋮----
{/* Mobile Cohort Selector using MobileDropdown component */}
⋮----
onClose=
⋮----
// Course Content using LearnerCohortView

================
File: src/app/school/[id]/page.tsx
================
import { useParams } from "next/navigation";
import ClientSchoolLearnerView from "./ClientSchoolLearnerView";
⋮----
export default function SchoolPage()

================
File: src/app/school/admin/[id]/cohorts/[cohortId]/ClientCohortPage.tsx
================
import { useState, useEffect, useRef, useCallback } from "react";
import { Header } from "@/components/layout/header";
import { Users, BookOpen, Layers, ArrowLeft, UsersRound, X, Plus, Trash2, Upload, Mail, ChevronDown, Check, FileText, ChevronRight, GraduationCap, School, HelpCircle, Pencil, ExternalLink, Settings } from "lucide-react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import ConfirmationDialog from "@/components/ConfirmationDialog";
import Toast from "@/components/Toast";
import CoursePublishSuccessBanner from "@/components/CoursePublishSuccessBanner";
import ClientLeaderboardView from "@/app/school/[id]/cohort/[cohortId]/leaderboard/ClientLeaderboardView";
import Tooltip from "@/components/Tooltip";
import CohortMemberManagement from "@/components/CohortMemberManagement";
import CohortDashboard from "@/components/CohortDashboard";
import CohortCoursesLinkerDropdown from "@/components/CohortCoursesLinkerDropdown";
import SettingsDialog from "@/components/SettingsDialog";
import { CohortWithDetails as Cohort } from "@/types";
import { DripConfig } from "@/types/course";
⋮----
interface Course {
    id: number;
    name: string;
    description?: string;
    moduleCount?: number;
    drip_config?: DripConfig;
}
⋮----
type TabType = 'dashboard' | 'learners' | 'mentors';
⋮----
interface ClientCohortPageProps {
    schoolId: string;
    cohortId: string;
}
⋮----
interface InviteModalProps {
    isOpen: boolean;
    onClose: () => void;
    onSubmit: (emails: string[]) => Promise<void>;
    submitButtonText: string;
    isSubmitting: boolean;
    role: 'learner' | 'mentor';
}
⋮----
// Add new interface for course metrics
interface CourseMetrics {
    average_completion: number;
    num_tasks: number;
    num_active_learners: number;
    task_type_metrics: {
        quiz?: {
            completion_rate: number;
            count: number;
        };
        learning_material?: {
            completion_rate: number;
            count: number;
        };
        exam?: {
            completion_rate: number;
            count: number;
        };
    };
}
⋮----
// Add state to track total courses in the school
⋮----
// Toast state
⋮----
// Add state for controlling the invite dialog
⋮----
// Add two new state variables, below existing state variables like isDeleteConfirmOpen
⋮----
// Add state for course publish success banner
⋮----
// Add state for cohort name editing
⋮----
// Add state for school slug
⋮----
// Function to switch to learners tab and open invite dialog
const handleOpenLearnerInviteDialog = () =>
⋮----
// Function to close the learner invite dialog
const handleCloseLearnerInviteDialog = () =>
⋮----
// Add useEffect to automatically hide toast after 5 seconds
⋮----
// Cleanup the timer when component unmounts or showToast changes
⋮----
const fetchAvailableCourses = async () =>
⋮----
// Store the total number of courses in the school
⋮----
// Function to handle removing a course from the cohort
const removeCourseFromCohort = async (courseId: number) =>
⋮----
// Check if this was the last course and set tab to 'learners' if so
⋮----
// Show success toast
⋮----
// Show error toast
⋮----
// Reset state
⋮----
// New function to initiate the course unlinking process with confirmation
const initiateCourseUnlink = (course: Course) =>
⋮----
// Add a function to handle the course linking from the dropdown component
const handleCoursesLinked = async (selectedCourses: Course[], dripConfig?: DripConfig) =>
⋮----
// Update the cohort with added courses
⋮----
// Get existing course IDs to avoid duplicates - ensure courses is always an array
⋮----
// Filter out any courses that are already in the cohort
⋮----
// Add course settings to the new courses if provided
⋮----
// Update selected course IDs
⋮----
// Remove added courses from available courses
⋮----
// Set course link details for success banner
⋮----
// Show success banner
⋮----
// Set tab to dashboard after successfully linking courses
⋮----
// Add a function to close the course publish banner
const closeCoursePublishBanner = () =>
⋮----
// Function to enable cohort name editing
const enableCohortNameEditing = () =>
⋮----
// Place cursor at the end of the text
⋮----
// Function to save edited cohort name
const saveCohortName = async () =>
⋮----
// Check if name is empty and show toast
⋮----
// Update local state with new name
⋮----
// Show success toast
⋮----
// Show error toast
⋮----
// Function to cancel cohort name editing
const cancelCohortNameEditing = () =>
⋮----
// Restore the original cohort name in the contentEditable element
⋮----
// Function to handle cohort name input
const handleCohortNameInput = (e: React.FormEvent<HTMLHeadingElement>) =>
⋮----
// Function to handle keydown events on cohort name input
const handleCohortNameKeyDown = (e: React.KeyboardEvent<HTMLHeadingElement>) =>
⋮----
// Function to copy invite link and show toast
const handleInviteLearners = async () =>
⋮----
// Function to handle opening settings dialog
const handleOpenSettingsDialog = (course: Course) =>
⋮----
// Function to close settings dialog
const handleCloseSettingsDialog = () =>
⋮----
const fetchCohort = async () =>
⋮----
// Fetch school details to get the slug
⋮----
// Fetch courses in cohort
⋮----
// Set default tab to dashboard if courses exist
⋮----
// Set default tab to learners if no courses exist
⋮----
// If cohort courses fetch fails, set empty array
⋮----
// Fetch available courses
⋮----
// Ensure cohort has empty courses array on error
⋮----
{/* Buttons container */}
⋮----
{/* Edit/Save/Cancel buttons */}
⋮----
{/* Link Course button and dropdown */}
⋮----
{/* Use the new dropdown component */}
⋮----
{/* Display linked courses below cohort name */}
⋮----
{/* Full-width tabs */}
⋮----
{/* Show Dashboard tab only when courses exist */}
⋮----
{/* Content sections with full width */}
⋮----
updateCohort=
⋮----
{/* Add the course unlinking confirmation dialog near the other dialog components
            at the end of the component, before the final Toast component */}
⋮----
{/* Toast notification */}
⋮----
{/* Add CoursePublishSuccessBanner component before the final closing tag */}
⋮----
{/* Add SettingsDialog component */}

================
File: src/app/school/admin/[id]/cohorts/[cohortId]/page.tsx
================
import ClientCohortPage from '@/app/school/admin/[id]/cohorts/[cohortId]/ClientCohortPage';
import { redirect } from 'next/navigation';
⋮----
export default function CohortPage(
⋮----
// If cohortId is undefined or the string 'undefined', redirect to the school page

================
File: src/app/school/admin/[id]/courses/[courseId]/learner-view/[learnerId]/ClientLearnerViewWrapper.tsx
================
import { useState, useEffect } from "react";
import LearnerCourseView from "@/components/LearnerCourseView";
import { Module } from "@/types/course";
import { getCompletionData } from "@/lib/api";
⋮----
interface ClientLearnerViewWrapperProps {
    modules: Module[];
    learnerId: string;
    cohortId: string;
    courseId: string;
    isAdminView: boolean;
}
⋮----
export default function ClientLearnerViewWrapper({
    modules,
    learnerId,
    cohortId,
    courseId,
    isAdminView
}: ClientLearnerViewWrapperProps)
⋮----
// State for tracking completed tasks and questions
⋮----
// Fetch learner progress data when component mounts
⋮----
const fetchLearnerProgress = async () =>
⋮----
// Fetch the learner's progress data

================
File: src/app/school/admin/[id]/courses/[courseId]/learner-view/[learnerId]/page.tsx
================
import { Metadata } from 'next';
import { Suspense } from 'react';
import { notFound } from 'next/navigation';
import ClientLearnerViewWrapper from './ClientLearnerViewWrapper';
import { getPublishedCourseModules } from '@/lib/server-api';
⋮----
export async function generateMetadata(
    { params }: { params: { id: string, cohortId: string, courseId: string, learnerId: string } }
): Promise<Metadata>
⋮----
// Fetch course and learner data
⋮----
// Use the new getPublishedCourseModules function to fetch and transform course data
⋮----
// Fetch learner data
⋮----
{/* Admin learner view banner */}

================
File: src/app/school/admin/[id]/courses/[courseId]/preview/ClientPreviewWrapper.tsx
================
import { useState, useEffect } from "react";
import LearnerCourseView from "@/components/LearnerCourseView";
import { Module } from "@/types/course";
⋮----
interface ClientPreviewWrapperProps {
    modules: Module[];
}
⋮----
// For preview mode, we use LearnerCourseView directly to ensure full-width display
// without the sidebar that LearnerCohortView would add

================
File: src/app/school/admin/[id]/courses/[courseId]/preview/page.tsx
================
import { Metadata } from 'next';
import { Suspense } from 'react';
import { notFound } from 'next/navigation';
import ClientPreviewWrapper from './ClientPreviewWrapper';
import { getPublishedCourseModules } from '@/lib/server-api';
⋮----
export async function generateMetadata(
    { params }: { params: { id: string, courseId: string } }
): Promise<Metadata>
⋮----
// Use the new getPublishedCourseModules function to fetch and transform course data
⋮----
{/* Preview announcement banner */}

================
File: src/app/school/admin/[id]/courses/[courseId]/page.tsx
================
import { useState, useRef, useEffect, useCallback } from "react";
import { ChevronUp, ChevronDown, X, ChevronRight, ChevronDown as ChevronDownExpand, Plus, BookOpen, HelpCircle, Trash, Zap, Eye, Check, FileEdit, Clipboard, ArrowLeft, Pencil, Users, UsersRound, ExternalLink, Sparkles, Loader2, Share, Settings } from "lucide-react";
import Link from "next/link";
import { Header } from "@/components/layout/header";
import { useRouter, useParams } from "next/navigation";
import CourseModuleList from "@/components/CourseModuleList";
import ConfirmationDialog from "@/components/ConfirmationDialog";
import Toast from "@/components/Toast";
import CoursePublishSuccessBanner from "@/components/CoursePublishSuccessBanner";
import { Module, ModuleItem, LearningMaterial, Quiz, DripConfig } from "@/types/course";
import { Milestone } from "@/types";
import { transformMilestonesToModules } from "@/lib/course";
import { CourseCohortSelectionDialog } from "@/components/CourseCohortSelectionDialog";
import { addModule } from "@/lib/api";
import Tooltip from "@/components/Tooltip";
import GenerateWithAIDialog, { GenerateWithAIFormData } from '@/components/GenerateWithAIDialog';
import SettingsDialog from "@/components/SettingsDialog";
⋮----
// Import the QuizQuestion type
import { QuizQuestion, QuizQuestionConfig } from "../../../../../../types/quiz";
⋮----
// Import the CreateCohortDialog
import CreateCohortDialog from '@/components/CreateCohortDialog';
⋮----
interface CourseDetails {
    id: number;
    name: string;
    milestones?: Milestone[];
}
⋮----
// Default configuration for new questions
⋮----
// Add state for course cohorts
⋮----
// Add state to track total cohorts in the school
⋮----
// Add refs for both buttons to position the dropdown
⋮----
// Add state to track which button opened the dialog
⋮----
// Add state for toast notifications
⋮----
// Add state for cohort removal confirmation
⋮----
// Add state for celebratory banner
⋮----
// Add a new state for direct create cohort dialog
⋮----
// Add state for AI generation dialog
⋮----
// Add state for course generation loading state
⋮----
// Add state for generation progress messages
⋮----
// Add a ref to store the WebSocket connection
⋮----
// Add a ref for the heartbeat interval
⋮----
// Add these new state variables after the existing state declarations
⋮----
// Add a new state variable to track generation completion
⋮----
// Add these refs after the existing refs declaration
⋮----
// Add state for selected cohort
⋮----
// Update the refs whenever the state changes
⋮----
// Extract fetchCourseDetails as a standalone function
const fetchCourseDetails = async () =>
⋮----
// Check if milestones are available in the response
⋮----
// Use the shared utility function to transform the milestones to modules
⋮----
// Add isEditing property required by the admin view
⋮----
// Check if any task in the course has isGenerating = true
⋮----
// Set up WebSocket connection if any task is being generated
⋮----
// Set the modules state
⋮----
// Fetch course details from the backend
⋮----
// Also fetch cohorts assigned to this course
⋮----
// Fetch school details to get the slug
const fetchSchoolDetails = async () =>
⋮----
// Check for dark mode
⋮----
// setIsDarkMode(document.documentElement.classList.contains('dark'));
⋮----
// Optional: Listen for changes to the dark mode
// const observer = new MutationObserver((mutations) => {
//     mutations.forEach((mutation) => {
//         if (mutation.attributeName === 'class') {
//             setIsDarkMode(document.documentElement.classList.contains('dark'));
//         }
//     });
// });
⋮----
// observer.observe(document.documentElement, { attributes: true });
⋮----
// return () => {
//     observer.disconnect();
// };
⋮----
// Set initial content and focus on newly added modules and items
⋮----
// Focus the newly added module
⋮----
// Focus the newly added item
⋮----
// Handle Escape key to close dialog
⋮----
const handleEscKey = (e: KeyboardEvent) =>
⋮----
// Handle clicks outside of the dropdown for the publish dialog
⋮----
// Add back the handleKeyDown function for module titles
const handleKeyDown = (e: React.KeyboardEvent<HTMLHeadingElement>) =>
⋮----
// Prevent creating a new line when pressing Enter
⋮----
// Remove focus
⋮----
const updateModuleTitle = (id: string, title: string) =>
⋮----
const toggleModuleEditing = (id: string, isEditing: boolean) =>
⋮----
const deleteModule = (id: string) =>
⋮----
// Update positions after deletion
⋮----
const moveModuleUp = (id: string) =>
⋮----
// Swap with previous module
⋮----
// Update positions
⋮----
const moveModuleDown = (id: string) =>
⋮----
// Swap with next module
⋮----
// Update positions
⋮----
const toggleModule = (id: string) =>
⋮----
// Add these new helper functions after the toggleModule function and before the addLearningMaterial function
// Helper function to add an item to a module's items array at a specific position
const addItemToState = (moduleId: string, newItem: ModuleItem, position: number) =>
⋮----
setIsDialogOpen(true); // Open the dialog for the new item
⋮----
// Insert the new item at the correct position and update positions of items below
⋮----
const addLearningMaterialToState = (moduleId: string, taskData: any, position: number) =>
⋮----
content: [], // Empty content, the editor will initialize with default content
⋮----
const addQuizToState = (moduleId: string, taskData: any, position: number) =>
⋮----
// Add handleDuplicateItem function to handle task duplication
const handleDuplicateItem = async (moduleId: string, taskData: any, position: number) =>
⋮----
// Find the original module for placement
⋮----
// Update the UI based on the task type
⋮----
// Auto-hide toast after 3 seconds
⋮----
// Show error toast
⋮----
// Auto-hide toast after 3 seconds
⋮----
// Modify the existing addLearningMaterial function to use the new helper
const addLearningMaterial = async (moduleId: string) =>
⋮----
// Make API request to create a new learning material
⋮----
// Get the learning material ID from the response
⋮----
// Update the UI using the abstracted helper function
⋮----
// You might want to show an error message to the user here
⋮----
// Modify the existing addQuiz function to use the new helper
const addQuiz = async (moduleId: string) =>
⋮----
// Make API request to create a new quiz
⋮----
// Get the quiz ID from the response
⋮----
// Update the UI using the abstracted helper function
⋮----
// You might want to show an error message to the user here
⋮----
const deleteItem = (moduleId: string, itemId: string) =>
⋮----
const moveItemUp = (moduleId: string, itemId: string) =>
⋮----
const moveItemDown = (moduleId: string, itemId: string) =>
⋮----
// Open the dialog for editing a learning material or quiz
const openItemDialog = (moduleId: string, itemId: string) =>
⋮----
// Ensure quiz items have questions property initialized
⋮----
// Update the module with the fixed item
⋮----
// For learning materials, we don't need to fetch content here
// The LearningMaterialEditor will fetch its own data using the taskId
⋮----
// For other types like exams, just open the dialog
⋮----
// Close the dialog
const closeDialog = () =>
⋮----
// Dialog confirmation is handled by CourseItemDialog component
⋮----
// Cancel edit mode and revert to original state
const cancelEditMode = () =>
⋮----
// For learning materials, the LearningMaterialEditor has already reverted the changes
// We need to revert the activeItem object to reflect the original state
⋮----
// Find the original module item from modules state
⋮----
// Reset activeItem to match the original state
⋮----
// Exit edit mode without saving changes
⋮----
// Add a function to update quiz questions
const updateQuizQuestions = (moduleId: string, itemId: string, questions: QuizQuestion[]) =>
⋮----
// Handle quiz content changes
const handleQuizContentChange = (questions: QuizQuestion[]) =>
⋮----
// Add a new function to handle the actual publishing after confirmation
const handleConfirmPublish = async () =>
⋮----
// For learning materials and quizzes, the API call is now handled in their respective components
// We need to update the modules list to reflect the status change
// The title update is handled in the CourseItemDialog's onPublishSuccess callback
⋮----
// Update the module item in the modules list with the updated status and title
⋮----
// Hide the confirmation dialog
⋮----
// Add a function to update a module item's status and title
const updateModuleItemAfterPublish = (moduleId: string, itemId: string, status: string, title: string, scheduled_publish_at: string | null) =>
⋮----
// Get numQuestions from activeItem if available (for quizzes)
⋮----
// Add a function to handle canceling the publish action
const handleCancelPublish = () =>
⋮----
const saveModuleTitle = async (moduleId: string) =>
⋮----
// Find the heading element by data attribute
⋮----
// Get the current content
⋮----
// Make API call to update the milestone on the server
⋮----
// If successful, update the state
⋮----
// Show toast notification
⋮----
// Auto-hide toast after 3 seconds
⋮----
// Still update the local state even if the API call fails
// This provides a better user experience while allowing for retry later
⋮----
// Show error toast
⋮----
// Auto-hide toast after 3 seconds
⋮----
// Turn off editing mode
⋮----
const cancelModuleEditing = (moduleId: string) =>
⋮----
// Find the heading element
⋮----
// Reset the content to the original title from state
⋮----
// Turn off editing mode
⋮----
// Add this helper function before the return statement
const hasAnyItems = () =>
⋮----
// Add these functions for course title editing
const handleCourseTitleInput = (e: React.FormEvent<HTMLHeadingElement>) =>
⋮----
// Just store the current text content, but don't update the state yet
// This prevents React from re-rendering and resetting the cursor
⋮----
// We'll update the state when the user finishes editing
⋮----
const saveCourseTitle = () =>
⋮----
// Make a PUT request to update the course name
⋮----
// Update the course title in the UI
⋮----
// Revert to the original title in case of error
⋮----
const cancelCourseTitleEditing = () =>
⋮----
// Helper function to set cursor at the end of a contentEditable element
const setCursorToEnd = (element: HTMLElement) =>
⋮----
// Clear any existing selection first
⋮----
// Set range to end of content
⋮----
range.collapse(false); // false means collapse to end
⋮----
// Apply the selection
⋮----
// For course title editing
const enableCourseTitleEditing = () =>
⋮----
// Need to use setTimeout to ensure the element is editable before focusing
⋮----
// For module title editing
const enableModuleEditing = (moduleId: string) =>
⋮----
// More reliable method to set cursor at end with a sufficient delay
⋮----
// Create a text node at the end for more reliable cursor placement
⋮----
// Place cursor at the end of the text
⋮----
}, 100); // Increased delay for better reliability
⋮----
// Modified function to enable edit mode
const enableEditMode = () =>
⋮----
// Focus the title for editing is now handled in CourseModuleList
⋮----
// Save the current item
const saveItem = async () =>
⋮----
// Update the modules state to reflect any changes in the UI
⋮----
// Common properties to update for all item types
⋮----
// Create updated items based on type with proper type assertions
⋮----
// Default case - update common properties
⋮----
// Exit edit mode
⋮----
const handleCohortSearch = (e: React.ChangeEvent<HTMLInputElement>) =>
⋮----
// Always filter the existing cohorts client-side
⋮----
// Show all available cohorts
⋮----
// Filter by search query
⋮----
// Update fetchCohorts to only be called once when dialog opens
const fetchCohorts = async () =>
⋮----
// First, fetch cohorts that are already assigned to this course
⋮----
// Then, fetch all cohorts for the organization
⋮----
// Store the total number of cohorts in the school
⋮----
// Filter out cohorts that are already assigned to the course
⋮----
// Set all available cohorts as filtered cohorts initially
⋮----
// Function to select a cohort
const selectCohort = (cohort: any) =>
⋮----
// Set the selected cohort (replacing any previous selection)
⋮----
// Update to publish to selected cohort
const publishCourseToSelectedCohort = async () =>
⋮----
// Show loading state
⋮----
// Link the course to the selected cohort
⋮----
// Create a reusable function for linking a course to cohorts
const linkCourseToCohort = async (
        cohortId: number,
        cohortName: string,
        dripConfig?: DripConfig
) =>
⋮----
// Make a single API call with all cohort IDs and drip config
⋮----
// Check if the request failed
⋮----
// Update cohort details for the celebration - use the first cohort for single cohort display
⋮----
// Show the celebratory banner
⋮----
// Reset selection
⋮----
// Refresh the displayed cohorts
⋮----
// Function to fetch cohorts assigned to this course
const fetchCourseCohorts = async () =>
⋮----
// Silently fail - don't show an error message to the user
⋮----
// Add a new function to initiate cohort removal with confirmation
const initiateCohortRemoval = (cohortId: number, cohortName: string) =>
⋮----
// Modify the existing removeCohortFromCourse function to handle the actual removal
const removeCohortFromCourse = async (cohortId: number) =>
⋮----
// Show success toast
⋮----
// Auto-hide toast after 5 seconds
⋮----
// Refresh the displayed cohorts
⋮----
// Reset the confirmation state
⋮----
// Show error toast
⋮----
// Auto-hide toast after 5 seconds
⋮----
// Reset the confirmation state even on error
⋮----
// Add toast close handler
const handleCloseToast = () =>
⋮----
// Add handler for closing the celebratory banner
const closeCelebratoryBanner = () =>
⋮----
// Update to handle dialog opening from either button
const openCohortSelectionDialog = async (origin: 'publish' | 'add') =>
⋮----
// For publish action, check if we need to auto-create a cohort
⋮----
// First, fetch all cohorts for the organization to check if any exist
⋮----
// If no cohorts exist at all, auto-create one and publish
⋮----
// Check cohorts already assigned to this course
⋮----
// Filter out cohorts that are already assigned to the course
⋮----
// If all cohorts are already assigned, show the dialog (don't auto-create)
// The dialog will handle showing the appropriate message and create button
⋮----
// Fall back to showing the dialog if there's an error
⋮----
// Toggle dialog if clicking the same button that opened it
⋮----
// Close the dialog if it's already open with the same origin
⋮----
// Open the dialog with the new origin
⋮----
setSelectedCohort(null); // Reset selected cohort
⋮----
// Update to handle dialog closing
const closeCohortDialog = () =>
⋮----
// Add handler for opening the create cohort dialog directly
const openCreateCohortDialog = () =>
⋮----
// Close the cohort selection dialog first
⋮----
// Then open the create cohort dialog
⋮----
// Add handler for closing the create cohort dialog
const closeCreateCohortDialog = () =>
⋮----
// Add handler for cohort creation and linking
const handleCohortCreated = async (cohort: any, dripConfig?: DripConfig) =>
⋮----
// Close the create cohort dialog first
⋮----
// Link the course to the newly created cohort using the reusable function
⋮----
// Show error toast
⋮----
// Auto-hide toast after 5 seconds
⋮----
// Add useEffect for WebSocket cleanup
⋮----
// Cleanup function
⋮----
// Close WebSocket when component unmounts
⋮----
// Clear heartbeat interval
⋮----
// Add a useEffect to watch for completion of task generation
⋮----
// Check if all tasks have been generated
⋮----
// Add final completion message
⋮----
// Set generation as complete
⋮----
// Close WebSocket connection when all tasks are completed
⋮----
// Update the handleGenerationDone function to reset the isGenerationComplete state
const handleGenerationDone = () =>
⋮----
const setupGenerationWebSocket = () =>
⋮----
// Set up WebSocket connection for real-time updates
⋮----
// Create new WebSocket and store in ref
⋮----
// Set up heartbeat to keep connection alive
// Typically sending a ping every 30 seconds prevents timeout
⋮----
// Send a simple ping message to keep the connection alive
⋮----
// Clear the interval if the WebSocket is closed
⋮----
}, 30000); // 30 seconds interval
⋮----
// Add the new module to the list of modules
⋮----
// Course structure generation is complete
⋮----
setGeneratedTasksCount(0); // Reset counter when starting task generation
⋮----
// Now we can start the task generation
⋮----
// Handle error appropriately
⋮----
// Increment the generated tasks counter
⋮----
// Add the new task to the appropriate module
⋮----
// Create appropriate item based on type
⋮----
// Mark this specific task as no longer generating
⋮----
// Update the module item to remove the isGenerating flag
⋮----
// Update items in this module
⋮----
// Clear heartbeat interval
⋮----
// Attempt to reconnect if generation is still in progress
⋮----
// Add a small delay before attempting to reconnect
⋮----
// Try to setup a new WebSocket connection
⋮----
}, 500); // small delay before reconnection attempt
⋮----
// Add handler for AI course generation
const handleGenerateCourse = async (data: GenerateWithAIFormData) =>
⋮----
// Close the dialog first
⋮----
// Set generating state and initialize with first progress message
⋮----
setIsGenerationComplete(false); // Reset completion state
⋮----
// Clear any existing WebSocket connection
⋮----
// Clear any existing heartbeat interval
⋮----
// For now, we'll just log the data
// In a real implementation, this would be an API call to start the generation process
⋮----
// First, get a presigned URL for the file
⋮----
// If we couldn't get a presigned URL, try direct upload to the backend
⋮----
// Create FormData for the file upload
⋮----
// Upload directly to the backend
⋮----
// Upload the file to S3 using the presigned URL
⋮----
// Use data.referencePdf instead of undefined 'file' variable
⋮----
// Upload to S3 using the presigned URL
⋮----
body: pdfFile, // Use the file directly, no need to create a Blob
⋮----
// Set up WebSocket connection for real-time updates
⋮----
// Make API request to generate course structure
⋮----
// Close WebSocket on API error
⋮----
// We'll set a listener for the course structure completion
// instead of immediately setting it as complete
⋮----
// Wait for the WebSocket to notify that the course structure is complete
// Instead of immediately calling the tasks endpoint
⋮----
// Close WebSocket on API error
⋮----
// Clean up WebSocket
⋮----
// Clear heartbeat interval
⋮----
// Add error message to progress
⋮----
// Reset generating state after delay
⋮----
// Add handler for copying cohort invite link
const handleCopyCohortInviteLink = async (cohortId: number, cohortName: string) =>
⋮----
// Show success toast
⋮----
// Auto-hide toast after 3 seconds
⋮----
// Show error toast
⋮----
// Auto-hide toast after 3 seconds
⋮----
// Function to handle opening settings dialog
const handleOpenSettingsDialog = (cohort: any) =>
⋮----
// Function to close settings dialog
const handleCloseSettingsDialog = () =>
⋮----
{/* Use the reusable Header component with showCreateCourseButton set to false */}
⋮----
{/* Add overlay when course is being generated */}
⋮----
{/* Show spinner when loading */}
⋮----
/* Main content area - only shown after loading */
⋮----
{/* Back to Courses button */}
⋮----
{/* Add published pill when course is in at least one cohort */}
⋮----
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
⋮----
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
⋮----
// Open preview in a new tab
⋮----
{/* Display cohorts assigned to this course */}
⋮----
{/* Generation Progress Window */}
⋮----
// Show spinner only for latest message when generation is not complete
⋮----
{/* Task generation progress bar - only shown after course structure is generated */}
⋮----
{/* Done button - only shown when generation is complete */}
⋮----
{/* Floating Action Button - Generate with AI - only shown when not generating */}
⋮----
{/* Render the CourseCohortSelectionDialog */}
⋮----
{/* Confirmation Dialog for Cohort Removal */}
⋮----
{/* Toast notification */}
⋮----
{/* Celebratory Banner for course publication */}
⋮----
{/* Add the standalone CreateCohortDialog */}
⋮----
{/* Generate with AI Dialog */}
⋮----
{/* Add SettingsDialog component */}

================
File: src/app/school/admin/[id]/ClientSchoolAdminView.tsx
================
import { useState, useEffect, useRef, useCallback } from "react";
import { Header } from "@/components/layout/header";
import { Edit, Save, Users, BookOpen, Layers, Building, ChevronDown, Trash2, ExternalLink } from "lucide-react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { useSession } from "next-auth/react";
import CourseCard from "@/components/CourseCard";
import CohortCard from "@/components/CohortCard";
import InviteMembersDialog from "@/components/InviteMembersDialog";
import CreateCohortDialog from "@/components/CreateCohortDialog";
import CreateCourseDialog from '@/components/CreateCourseDialog';
import Toast from "@/components/Toast";
import ConfirmationDialog from "@/components/ConfirmationDialog";
import { Cohort, TeamMember, Course } from "@/types";
⋮----
interface School {
    id: number;
    name: string;
    url: string;
    courses: Course[];
    cohorts: Cohort[];
    members: TeamMember[];
}
⋮----
type TabType = 'courses' | 'cohorts' | 'members';
⋮----
// Add state for selected members
⋮----
// Add state for toast notifications
⋮----
// Add useEffect to automatically hide toast after 5 seconds
⋮----
// Cleanup the timer when component unmounts or showToast changes
⋮----
// Initialize tab from URL hash
⋮----
// Check if there's a hash in the URL
⋮----
// Fetch school data
⋮----
const fetchSchool = async () =>
⋮----
// Fetch basic school info
⋮----
// Fetch members separately
⋮----
// Fetch cohorts separately
⋮----
// Fetch courses separately
⋮----
// Transform the API response to match the School interface
⋮----
moduleCount: 0, // Default value since API doesn't provide this
description: '' // Default value since API doesn't provide this
⋮----
members: membersData || []  // Use the members from the separate endpoint
⋮----
// Handle clicking outside the name edit field
⋮----
function handleClickOutside(event: MouseEvent)
⋮----
// Toggle name editing
const toggleNameEdit = () =>
⋮----
// Focus the name field when editing is enabled
⋮----
// Place cursor at the end of the text
⋮----
// Handle name blur
const handleNameBlur = () =>
⋮----
// Handle keyboard events for name editing
const handleNameKeyDown = (e: React.KeyboardEvent<HTMLHeadingElement>) =>
⋮----
const handleInviteMembers = async (emails: string[]) =>
⋮----
// Make API call to invite members
⋮----
// Refresh school data to get updated members list
⋮----
// Update school state with new members
⋮----
// Close the invite dialog
⋮----
// Show toast notification
⋮----
// Here you would typically show an error message to the user
⋮----
// Check if a member is the current user
const isCurrentUser = (member: TeamMember) =>
⋮----
const handleDeleteMember = (member: TeamMember) =>
⋮----
// Don't allow deleting yourself
⋮----
// Handle multiple members deletion
const handleDeleteSelectedMembers = () =>
⋮----
// Updated to handle both single and multiple member deletion
const confirmDeleteMember = async () =>
⋮----
// Make API call to delete member(s)
⋮----
// Refresh school data to get updated members list
⋮----
// Update school state with new members
⋮----
// Show toast notification for successful deletion
⋮----
// Here you would typically show an error message to the user
⋮----
// Handle member selection toggle
const handleMemberSelection = (member: TeamMember) =>
⋮----
// Don't allow selecting yourself
⋮----
// Check if this member is already selected
⋮----
// If selected, remove it; if not, add it
⋮----
// Handle "select all" functionality
const handleSelectAllMembers = (e: React.ChangeEvent<HTMLInputElement>) =>
⋮----
// Filter out owner members and current user since they can't be deleted
⋮----
// Check if all selectable members are selected
const areAllMembersSelected = () =>
⋮----
// Check if there are any members that can be selected/deleted
const hasSelectableMembers = () =>
⋮----
const handleCreateCohort = async (cohort: any) =>
⋮----
// Important: Navigate before closing the dialog to prevent flash of school page
// This navigation will unmount the current component, which implicitly closes the dialog
⋮----
// Fallback to schools page if ID is missing and close dialog
⋮----
// Handle course creation success
const handleCourseCreationSuccess = (courseData:
⋮----
// Redirect to the new course page - dialog will be unmounted during navigation
⋮----
// Handle tab change
const handleTabChange = (tab: TabType) =>
⋮----
// Only add hash for non-default tabs
⋮----
// Remove hash if it's the courses tab
⋮----
const handleCohortDelete = async (cohortId: number) =>
⋮----
// Refresh school data to get updated cohorts list
⋮----
// Update school state with new cohorts
⋮----
// Show toast notification for successful deletion
⋮----
// Here you would typically show an error message to the user
⋮----
const handleCourseDelete = async (courseId: string | number) =>
⋮----
// Refresh school data to get updated courses list
⋮----
// Update school state with new courses
⋮----
// Show toast notification for successful deletion
⋮----
// Here you would typically show an error message to the user
⋮----
{/* School header with title */}
⋮----
{/* <button
                                                onClick={toggleNameEdit}
                                                className="ml-2 p-2 text-gray-400 hover:text-white"
                                                aria-label={isEditingName ? "Save school name" : "Edit school name"}
                                            >
                                                {isEditingName ? <Save size={16} /> : <Edit size={16} />}
                                            </button> */}
⋮----
{/* Tabs for navigation */}
⋮----
{/* Tab content */}
⋮----
{/* Courses Tab */}
⋮----
{/* Cohorts Tab */}
⋮----
{/* Team Tab */}
⋮----
checked=
⋮----
{/* Invite Members Dialog */}
⋮----
{/* Delete Member Confirmation Dialog */}
⋮----
{/* Create cohort Dialog */}
⋮----
{/* Create course Dialog */}
⋮----
{/* Toast notification */}

================
File: src/app/school/admin/[id]/page.tsx
================
import ClientSchoolAdminView from './ClientSchoolAdminView';
import { useParams } from 'next/navigation';
⋮----
export default function SchoolPage()
⋮----
// Use the proper Next.js hook to get route parameters

================
File: src/app/school/admin/create/page.tsx
================
import React, { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { Header } from "@/components/layout/header";
import { useAuth } from "@/lib/auth";
import { useSchools } from "@/lib/api";
import { motion } from "framer-motion"; // Import Framer Motion
import { X } from "lucide-react"; // Import X icon
⋮----
// State for form fields
⋮----
// Add state for error message
⋮----
// Add state for success dialog
⋮----
// Check if user already has a school and redirect if they do
⋮----
// Base URL for the school (would come from environment variables in a real app)
⋮----
// Play success sound effect - a distinctive sound for school creation
const playSuccessSound = () =>
⋮----
// Create a more elaborate, celebratory sound with multiple oscillators
⋮----
// First oscillator - descending chime sound
⋮----
oscillator1.type = 'triangle'; // Triangle wave for a bell-like quality
⋮----
// Second oscillator - ascending tone
⋮----
// Third oscillator - higher pitch flourish
⋮----
oscillator3.type = 'square'; // Square wave for a bright quality
⋮----
// Create gain nodes with different envelope shapes
⋮----
// Connect nodes
⋮----
// Start and stop oscillators with different timings
⋮----
// Function to handle form submission
const handleSubmit = async (e: React.FormEvent) =>
⋮----
// Clear any previous errors
⋮----
// Create the school via API
⋮----
// Instead of redirecting, show success dialog
⋮----
// Error is already set if it's a slug error
⋮----
// Function to navigate to the new school
const navigateToSchool = () =>
⋮----
// Replace client-side navigation with a full page navigation
⋮----
// Effect to pre-fill name fields from user data if available
⋮----
// Animation variants for shooting stars
⋮----
// Animation variants for orbs
⋮----
// Function to navigate back to home
const handleGoBack = () =>
⋮----
{/* Close button - repositioned for better mobile experience */}
⋮----
{/* School Name */}
⋮----
{/* School URL */}
⋮----
{/* Submit Button */}
⋮----
{/* Success Dialog with Framer Motion animations */}
⋮----
{/* Shooting Stars using Framer Motion - adjusted for mobile */}
⋮----
const top = Math.random() * 40; // Random starting position
const left = Math.random() * 100 + 50; // Random starting position
const width = Math.random() * 100 + 40; // Adjusted for mobile: Between 40px and 140px
const delay = Math.random() * 2; // Random delay
⋮----
{/* Floating Orbs using Framer Motion - reduced quantity for mobile */}
⋮----
const left = (i % 3) * 30 + 10; // 3 orbs per row, evenly spaced
const size = 6 + (i % 3) * 3; // Smaller sizes for mobile: 6px, 9px, or 12px
const delay = i * 0.4; // Sequential delays
const hue = i % 2 === 0 ? 210 + (i * 5) : 180 - (i * 3); // Blues/purples
⋮----
{/* Dialog Content - Using Framer Motion for a subtle animation */}

================
File: src/app/school/admin/layout.tsx
================
import React, { useEffect, useState } from 'react';
import { usePathname } from 'next/navigation';
import { useAuth } from '@/lib/auth';
import { useSchools } from '@/lib/api';
import UnauthorizedError from '@/components/UnauthorizedError';
import { Header } from '@/components/layout/header';
⋮----
export default function AdminLayout(
⋮----
// Extract school ID from the URL if we are in a specific school admin view
⋮----
// Determine if the user has access to this school admin area
⋮----
// If we're on create page or similar, always allow
⋮----
// Check if user has admin or owner access to this school
⋮----
// Show loading state
⋮----
// If not authorized, show error page
⋮----
// User is authorized, render children

================
File: src/app/layout.tsx
================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
⋮----
import { SessionProvider } from "@/providers/SessionProvider";
⋮----
export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>)

================
File: src/app/page.tsx
================
import { useState, useEffect, useMemo, useCallback } from "react";
import { Header } from "@/components/layout/header";
import { useRouter } from "next/navigation";
import { useSession } from "next-auth/react";
import { useCourses, useSchools, Course as ApiCourse } from "@/lib/api";
import CourseCard from "@/components/CourseCard";
import CreateCourseDialog from "@/components/CreateCourseDialog";
⋮----
// Memoize derived data to avoid recalculations
⋮----
// Memoize initialActiveTab calculation
⋮----
// Update school state based on API data
⋮----
// Handle tab changes only when related data changes
⋮----
// Memoize event handlers
⋮----
// If school already exists, show the course creation dialog
⋮----
// If no school exists, redirect to school creation page
⋮----
// Handle success callback from CreateCourseDialog
⋮----
// Redirect to the new course page - dialog will be unmounted during navigation
⋮----
{/* Use the reusable Header component */}
⋮----
{/* Main content */}
⋮----
{/* Loading state */}
⋮----
{/* Content when loaded */}
⋮----
{/* Segmented control for tabs */}
⋮----
{/* Display content based on courses availability */}
⋮----
// No courses at all - show universal placeholder
⋮----
// User has some courses, show appropriate heading
⋮----
{/* Course grid */}
⋮----
{/* Create Course Dialog */}

================
File: src/components/layout/header.tsx
================
import Link from "next/link";
import Image from "next/image";
import { useState, useRef, useEffect } from "react";
import { useRouter } from "next/navigation";
import { signOut, useSession } from "next-auth/react";
import { useSchools } from "@/lib/api";
import CreateCourseDialog from "@/components/CreateCourseDialog";
import SchoolPickerDialog from "@/components/SchoolPickerDialog";
import { ChevronDown, Plus, X, Book, School } from "lucide-react";
import { Cohort } from "@/types";
⋮----
interface HeaderProps {
    showCreateCourseButton?: boolean;
    cohorts?: Cohort[];
    activeCohort?: Cohort | null;
    onCohortSelect?: (cohort: Cohort) => void;
    showTryDemoButton?: boolean;
}
⋮----
// Check if user has a school they own (role admin)
⋮----
// Use the first owned/admin school or just first school as fallback
⋮----
// Close the profile menu and mobile actions when clicking outside
⋮----
function handleClickOutside(event: MouseEvent)
⋮----
// Handle logout
const handleLogout = () =>
⋮----
// Toggle profile menu
const toggleProfileMenu = () =>
⋮----
// Toggle cohort dropdown
const toggleCohortDropdown = () =>
⋮----
// Toggle mobile actions menu
const toggleMobileActions = () =>
⋮----
// Handle cohort selection
const handleCohortSelect = (cohort: Cohort) =>
⋮----
// Handle button click based on school ownership
const handleButtonClick = (e: React.MouseEvent) =>
⋮----
// If no schools, redirect to school creation
⋮----
// If exactly one school and user is owner, go directly to that school
⋮----
// Otherwise show the school picker dialog
⋮----
// Handle selecting a school from the picker
const handleSelectSchool = (selectedSchoolId: string) =>
⋮----
// Handle creating a new school
const handleCreateSchool = () =>
⋮----
// Handle creating a new course button click
const handleCreateCourseButtonClick = () =>
⋮----
// Handle success callback from CreateCourseDialog
const handleCourseCreationSuccess = (courseData:
⋮----
// Redirect to the new course page - dialog will be unmounted during navigation
⋮----
// Handle go to school button click
const handleGoToSchoolClick = () =>
⋮----
// Add handler for "Try a demo" button click
const handleTryDemoClick = () =>
⋮----
// Get user initials for avatar
const getInitials = () =>
⋮----
// Get appropriate button text based on conditions
const getButtonText = () =>
⋮----
{/* Logo */}
⋮----
{/* Center - Cohort Selector or Active Cohort Name */}
⋮----
{/* Right side actions */}
⋮----
{/* Profile dropdown */}
⋮----
{/* Profile dropdown menu */}
⋮----
{/* Mobile Floating Action Button and Menu */}
⋮----
{/* Semi-transparent overlay */}
⋮----
{/* Main FAB button and menu contents */}
⋮----
{/* Main FAB button */}
⋮----
{/* Action buttons that appear when FAB is clicked */}
⋮----
{/* Try a demo Button - only shown if not already a learner */}
⋮----
{/* Go To School Button - only shown if hasOwnedSchool is true */}
⋮----
) : /* Create Course Button */ <div className="flex items-center gap-3">
⋮----
{/* Create Course Dialog */}
⋮----
{/* School Picker Dialog */}

================
File: src/components/ui/avatar.tsx
================
import { cn } from "@/lib/utils"

================
File: src/components/ui/button.tsx
================
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
⋮----
import { cn } from "@/lib/utils"
⋮----
export interface ButtonProps
    extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
    asChild?: boolean
}

================
File: src/components/ui/card.tsx
================
import { cn } from "@/lib/utils"
⋮----
className=
⋮----
<div ref=

================
File: src/components/ui/tabs.tsx
================
import { cn } from "@/lib/utils"

================
File: src/components/AudioInputComponent.tsx
================
import { useState, useEffect, useRef } from 'react';
import { Mic, Play, Send, Pause, Trash2 } from 'lucide-react';
⋮----
interface AudioInputComponentProps {
    onAudioSubmit: (audioBlob: Blob) => void;
    isSubmitting: boolean;
    maxDuration?: number;
    isDisabled?: boolean;
}
⋮----
// Shared waveform rendering function to avoid duplication
⋮----
// Apply exponential scaling to emphasize differences
⋮----
// Determine if this bar is in the played portion
⋮----
// Function to get supported MIME type
⋮----
''  // empty string means browser default
⋮----
return '';  // Return empty string as fallback (browser default)
⋮----
// Basic states
⋮----
// Separate waveform data states for live recording and snapshot
⋮----
// Refs
⋮----
// Initialize audio player
⋮----
// Clean up on unmount
⋮----
// Start recording function
const startRecording = async () =>
⋮----
// Reset everything
⋮----
// Create audio context
⋮----
// Get microphone stream
⋮----
// Create and configure analyser
⋮----
// Connect microphone stream to analyser
⋮----
// Replace the MediaRecorder initialization with:
⋮----
// When data becomes available, add it to our array
⋮----
// When recording stops
⋮----
// Create audio blob from recorded chunks
⋮----
// Set up audio player
⋮----
// Set up event listeners
⋮----
// Generate snapshot waveform from the recorded audio
⋮----
// Clean up
⋮----
// Set recording state first
⋮----
// Start recording
⋮----
// Set timer for recording duration
⋮----
// Start visualization after setting recording state
⋮----
// Update the live waveform during recording
const updateLiveWaveform = (analyser: AnalyserNode) =>
⋮----
// This function gets called continuously by requestAnimationFrame
const draw = () =>
⋮----
// Get time domain data for waveform visualization
⋮----
// Process the data to create the waveform (sample to ~40 points for visualization)
⋮----
// Average a few points together
⋮----
// For time domain data, we want the absolute deviation from 128 (midpoint)
⋮----
// Normalize to 0-1 range
⋮----
// Limit to 40 data points
⋮----
// Update live waveform state
⋮----
// Continue the animation loop
⋮----
// Start the animation loop
⋮----
// Stop recording
const stopRecording = () =>
⋮----
// Cancel animation frame here
⋮----
// Toggle audio playback
const togglePlayback = () =>
⋮----
// If snapshot waveform data is empty, try to generate it from the recorded audio
⋮----
// Function to generate snapshot waveform data from an audio blob
const generateWaveformFromAudio = async (blob: Blob) =>
⋮----
// Create a new audio context
⋮----
// Convert blob to array buffer
⋮----
// Decode the audio data
⋮----
// Get the channel data
⋮----
// Sample the audio data to create waveform
⋮----
// Average and normalize (audio data is -1 to 1)
// Use a different normalization factor to accentuate differences
const normalized = sum / (blockSize * 0.8); // Increase visibility by reducing divisor
sampledData.push(Math.min(normalized, 1)); // Cap at 1
⋮----
// Apply some smoothing to make the waveform look more natural
⋮----
// Weighted average with current sample having more weight
⋮----
// Update snapshot waveform data
⋮----
// Close the audio context
⋮----
// Seek in audio playback
const handleSeek = (e: React.MouseEvent<HTMLDivElement>) =>
⋮----
// Submit recorded audio
const handleSubmit = () =>
⋮----
// Close the delete confirmation dialog if it's open
⋮----
// Format time for display
const formatTime = (seconds: number) =>
⋮----
// New function to handle delete button click
const handleDeleteClick = () =>
⋮----
// New function to confirm deletion
const confirmDelete = () =>
⋮----
// Stop playback if it's playing
⋮----
// Reset all audio-related states
⋮----
// Close confirmation dialog
⋮----
// Clear audio player source if it exists
⋮----
// New function to cancel deletion
const cancelDelete = () =>
⋮----
{/* Recording status and timer */}
⋮----
{/* Delete confirmation dialog */}
⋮----
{/* Main container */}
⋮----
{/* Record/Play/Stop button */}
⋮----
{/* Redesigned layout with waveform extending full width */}
⋮----
{/* Flex container for waveform and submit button */}
⋮----
{/* Waveform container that adjusts width based on recording state */}
⋮----
? 'flex-1 max-w-[calc(100%-80px)] sm:max-w-none' // Add max-width constraint on mobile
⋮----
{/* Waveform visualization - show different components based on state */}
⋮----
{/* Action buttons - added delete button */}
⋮----
{/* Delete button */}
⋮----
{/* Submit button */}
⋮----
<svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" className="sm:hidden">
⋮----
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" className="hidden sm:block">

================
File: src/components/BlockNoteEditor.tsx
================
import { useCreateBlockNote } from "@blocknote/react";
import { BlockNoteView } from "@blocknote/mantine";
⋮----
import { useEffect, useRef, useState } from "react";
import { BlockNoteSchema, defaultBlockSpecs, locales } from "@blocknote/core";
import Toast from "./Toast";
⋮----
// Add custom styles for dark mode
⋮----
interface BlockNoteEditorProps {
    initialContent?: any[];
    onChange?: (content: any[]) => void;
    isDarkMode?: boolean;
    className?: string;
    readOnly?: boolean;
    placeholder?: string;
    onEditorReady?: (editor: any) => void;
    allowMedia?: boolean;
}
⋮----
// Uploads a file and returns the URL to the uploaded file
async function uploadFile(file: File)
⋮----
// First, get a presigned URL for the file
⋮----
// If we couldn't get a presigned URL, try direct upload to the backend
⋮----
// Create FormData for the file upload
⋮----
// Upload directly to the backend
⋮----
// Upload the file to S3 using the presigned URL
⋮----
// Upload to S3 using the presigned URL with WAV content type
⋮----
// Update the request body with the file information
⋮----
async function resolveFileUrl(url: string)
⋮----
// Get presigned URL
⋮----
// Function to check if a URL is a YouTube link
function isYouTubeLink(url: string): boolean
⋮----
export default function BlockNoteEditor({
    initialContent = [],
    onChange,
    isDarkMode = true, // Default to dark mode
    className = "",
    readOnly = false,
    placeholder = "Enter text or type '/' for commands",
    onEditorReady,
    allowMedia = true,
}: BlockNoteEditorProps)
⋮----
isDarkMode = true, // Default to dark mode
⋮----
// Replace the boolean showToast with a toast object
⋮----
// Add a timeout ref to store the timeout ID
⋮----
// Extract blocks we don't want based on configuration
⋮----
// If media is allowed, exclude only these blocks
⋮----
// If media is not allowed, also exclude all media blocks
⋮----
// Create a schema with only the allowed blocks
⋮----
// Creates a new editor instance with the custom schema
⋮----
schema, // Use our custom schema with limited blocks
⋮----
// Store the editor instance in a ref for later use
⋮----
// Update the function to handle closing the toast
const handleCloseToast = () =>
⋮----
// Clear any existing timeout
⋮----
// Update the effect that checks for YouTube links
⋮----
const handleVideoBlockChange = () =>
⋮----
// Skip checking during programmatic updates
⋮----
// Get all video blocks
⋮----
// Check if this is a video block
// @ts-ignore - TypeScript doesn't recognize custom block types
⋮----
// Check if the URL is a YouTube link
// @ts-ignore - TypeScript doesn't recognize props on custom block types
⋮----
// Show toast with customized properties
⋮----
// Clear any existing timeout
⋮----
// Set a new timeout to auto-hide the toast after 5 seconds
⋮----
// Listen for content changes to detect YouTube links
⋮----
// Cleanup function to clear timeout when component unmounts
⋮----
// Provide the editor instance to the parent component if onEditorReady is provided
⋮----
// Update editor content when initialContent changes
⋮----
// Set flag to prevent triggering onChange during programmatic update
⋮----
// Only replace blocks if the content has actually changed
⋮----
// Reset flag after update
⋮----
// Handle content changes with debouncing to avoid rapid state updates
⋮----
const handleChange = () =>
⋮----
// Prevent handling changes if we're currently updating content
⋮----
// Add change listener
⋮----
// Add a method to focus the editor
⋮----
// Add a focus method to the editor ref
// Use a different name for the method to avoid potential name conflicts
⋮----
// Check if we're already focused to prevent recursion
⋮----
// Only focus if we're not already focused
⋮----
// Add effect to handle clicks in the empty space of editor blocks
⋮----
const handleEditorClick = (e: MouseEvent) =>
⋮----
// Don't interfere with normal clicks on content
⋮----
// Check if we're clicking on the editor container but not on an actual block content
⋮----
// Find the closest block element to the click
⋮----
// Find the block at the click position
⋮----
// Check if the click is on the same line as this block (y-axis)
⋮----
// Explicitly reassert the type right where we need it
⋮----
// Get the editable element within the block
⋮----
// Focus and place cursor at the end
⋮----
// Set selection to the end of the content
⋮----
range.collapse(false); // false means collapse to end
⋮----
// Add click handler to prevent event propagation
⋮----
e.stopPropagation();
⋮----
// Prevent mousedown from bubbling up which can cause focus issues
⋮----
{/* Update Toast component to use the toast object */}

================
File: src/components/ChatHistoryView.tsx
================
import React, { useRef, useEffect, useState } from 'react';
import { ChatMessage, ScorecardItem } from '../types/quiz';
import Markdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
⋮----
// Code message display component
⋮----
// Check if the code contains language headers (e.g., "// JAVASCRIPT", "// HTML", etc.)
⋮----
// Split the code by language sections
⋮----
// Create an array of [language, code] pairs
⋮----
// If no language headers, display as a single code block
⋮----
// State for current thinking message
⋮----
// State to track animation transition
⋮----
// Ref to store the interval ID for proper cleanup
⋮----
// Ref to store the timeout ID for proper cleanup
⋮----
// Ref to store the current thinking message to avoid dependency issues
⋮----
// Ref to track if initial message has been set
⋮----
// Preset list of thinking messages for the AI typing animation
⋮----
// Update the ref when the state changes
⋮----
// Effect to change the thinking message every 2 seconds
⋮----
// Only set up the interval if AI is responding
⋮----
// Clear any existing intervals/timeouts when AI stops responding
⋮----
// Reset the initial message flag when AI stops responding
⋮----
// Set initial message only if it hasn't been set yet
⋮----
// Set interval to change message every 2 seconds
⋮----
// First set transition state to true (starting the fade-out)
⋮----
// After a short delay, change the message and reset transition state
⋮----
// Get current message from the ref to avoid dependency issues
⋮----
// Filter out the current message to avoid repetition
⋮----
// Select a random message from the filtered list
⋮----
// Reset transition state (starting the fade-in)
⋮----
}, 200); // Short delay for the transition effect
⋮----
// Clean up interval and timeout on unmount or when dependencies change
⋮----
// Effect to scroll to the bottom of the chat when new messages are added
⋮----
// Custom styles for the animations
⋮----
// Helper to determine if "View Report" button should be shown
const shouldShowViewReport = (message: ChatMessage) =>
⋮----
// Check if message is from AI and has scorecard data
⋮----
// Check if the current question is configured for report responses
⋮----
// Helper to check if a message is an error message
const isErrorMessage = (message: ChatMessage) =>
⋮----
// Find the last AI message index
⋮----
Array.isArray(currentQuestionConfig?.codingLanguages) &&
⋮----
{/* Show "Preparing report" as an AI message */}
⋮----
{/* AI typing animation - with pulsating dot and changing text */}
⋮----
{/* Add global styles for animation */}

================
File: src/components/ChatPlaceholderView.tsx
================
import React from 'react';
⋮----
interface ChatPlaceholderViewProps {
    taskType: 'quiz' | 'learning_material';
    isChatHistoryLoaded: boolean;
    isTestMode: boolean;
    inputType?: string;
    viewOnly?: boolean;
    responseType?: 'chat' | 'exam';
}
⋮----
// Loading spinner while chat history is loading
⋮----
// Show placeholder text only when history is loaded but empty

================
File: src/components/ChatView.tsx
================
import React, { useRef, useEffect, useState, forwardRef, useImperativeHandle } from 'react';
import { ChatMessage, ScorecardItem, QuizQuestion } from '../types/quiz';
import ChatPlaceholderView from './ChatPlaceholderView';
import ChatHistoryView from './ChatHistoryView';
import AudioInputComponent from './AudioInputComponent';
import CodeEditorView, { CodeEditorViewHandle } from './CodeEditorView';
import Toast from './Toast';
import { MessageCircle, Code, Sparkles, Save } from 'lucide-react';
import isEqual from 'lodash/isEqual';
⋮----
// Export interface for code view state to be used by parent components
export interface CodeViewState {
    isViewingCode: boolean;
    isRunning: boolean;
    previewContent: string;
    output: string;
    hasWebLanguages: boolean;
    executionTime?: string;
}
⋮----
// Define MobileViewChangeEvent interface for the parent component
export interface MobileViewChangeEvent {
    mode: 'question-full' | 'chat-full' | 'split';
}
⋮----
interface ChatViewProps {
    currentChatHistory: ChatMessage[];
    isAiResponding: boolean;
    showPreparingReport: boolean;
    isChatHistoryLoaded: boolean;
    isTestMode: boolean;
    taskType: 'quiz' | 'learning_material';
    currentQuestionConfig?: any;
    isSubmitting: boolean;
    currentAnswer: string;
    handleInputChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
    handleSubmitAnswer: (responseType?: 'text' | 'code') => void;
    handleAudioSubmit: (audioBlob: Blob) => void;
    handleViewScorecard: (scorecard: ScorecardItem[]) => void;
    viewOnly?: boolean;
    completedQuestionIds: Record<string, boolean>;
    currentQuestionId?: string;
    handleRetry?: () => void;
    onCodeStateChange?: (state: CodeViewState) => void;
    initialIsViewingCode?: boolean;
    showLearnerView?: boolean;
    onShowLearnerViewChange?: (show: boolean) => void;
    isAdminView?: boolean;
    userId?: string;
}
⋮----
export interface ChatViewHandle {
    toggleCodeView: () => void;
}
⋮----
// Add ref for CodeEditorView
⋮----
// Add state for code editor toggle and preview
⋮----
// Determine if this is a coding question
⋮----
// Get coding languages from question config
⋮----
// Check if web preview is available (HTML, CSS, JS)
⋮----
// Determine if this question is completed
⋮----
// Store the previous state for comparison
⋮----
// Update view state when question config changes
⋮----
// Don't set viewing code in viewOnly mode
⋮----
// For completed exam questions, always show chat view to see the confirmation
⋮----
// Extract code from chat history for coding questions
⋮----
// Function to extract code from chat history
const extractCodeFromChatHistory = () =>
⋮----
// Filter messages to find code type messages
⋮----
// Use the most recent code message if any exists
⋮----
// Try to parse code sections based on language markers
⋮----
// Map common language variations
⋮----
// If no language headers were found, use the content as the first language
⋮----
// Ensure all configured languages have an entry
⋮----
// If a language doesn't have code yet, initialize with empty string
⋮----
// Set the code content for the editor
⋮----
// Check for saved code drafts first
const fetchSavedCode = async () =>
⋮----
// Try to get saved code first
⋮----
// Extract code from chat history if no saved code exists
⋮----
// Notify parent of code state changes
⋮----
// Only call onCodeStateChange if the state has actually changed
⋮----
// Handle code run
const handleCodeRun = (newPreviewContent: string, newOutput: string, newExecutionTime?: string, newIsRunning?: boolean) =>
⋮----
// Update isRunning based on the parameter if provided, otherwise use previous logic
⋮----
// Only set isRunning to false for web preview
⋮----
// Update parent component with current state
⋮----
// Handle code submission
const handleCodeSubmit = async (code: Record<string, string>) =>
⋮----
// Add code to chat history as a user message
⋮----
// Format the code for display in the chat
// You could display just the active language or all languages
// For simplicity, we'll combine all languages with headers
⋮----
// Create a formatted version of the code with language headers
⋮----
// Use the existing handleSubmitAnswer, but first set the currentAnswer to the code
// This is a workaround to reuse existing logic
⋮----
// Then call the submit function
⋮----
// Delete any existing code for this question before submitting new code
⋮----
// Continue with submission even if delete fails
⋮----
// For exam questions, keep the code editor visible so that users can review their code
⋮----
// Function to adjust textarea height based on content
const adjustTextareaHeight = () =>
⋮----
// Reset height to auto to get the correct scrollHeight
⋮----
// Calculate new height (capped at approximately 6 lines)
const lineHeight = 24; // Approximate line height in pixels
const maxHeight = lineHeight * 6; // Max height for 6 lines
⋮----
// Set the new height
⋮----
// Add scrolling if content exceeds maxHeight - ensure this isn't overridden by CSS
⋮----
// Adjust height when content changes
⋮----
// Reset textarea height when messages are sent
⋮----
// Focus the textarea when the component mounts
⋮----
// Modified handleKeyPress for textarea
const handleTextareaKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) =>
⋮----
// Submit on Enter key without shift key
⋮----
e.preventDefault(); // Prevent new line
⋮----
// Handle suggestion click
const handleSuggestionClick = (suggestion: string) =>
⋮----
// Use the handleInputChange to set the value in the input
⋮----
// Focus the textarea after setting the value
⋮----
// Handle save functionality
⋮----
const handleSave = async () =>
⋮----
// Convert code object to CodeDraft array
⋮----
// Only save if there's actual code content
⋮----
// Show success toast
⋮----
// Optionally show error feedback
⋮----
// Auto-hide save toast after 3 seconds
⋮----
// Render the code editor or chat view based on state
⋮----
// If viewing code and not in viewOnly mode, show the code editor
⋮----
{/* Input area with fixed position at bottom */}
⋮----
{/* Learning Material Suggestions */}
⋮----
/* Input area - conditional render based on input type */
⋮----
/* Hide the text input for coding questions in exam mode */
⋮----
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
⋮----
{/* Toggle button for coding questions */}
⋮----
// Hide toggle for exam questions that are completed
⋮----
{/* Save button - only show when code view is active */}
⋮----
{/* Chat/Code toggle */}
⋮----
{/* Main content area with code editor or chat view */}
⋮----
{/* Save Toast */}

================
File: src/components/CodeEditorView.tsx
================
import React, { useState, useEffect, useRef, forwardRef, useImperativeHandle } from 'react';
import Editor, { Monaco } from '@monaco-editor/react';
import { Play, Send, Terminal, ArrowLeft, X } from 'lucide-react';
import Toast from './Toast';
⋮----
interface CodeEditorViewProps {
    initialCode?: Record<string, string>;
    languages?: string[];
    handleCodeSubmit: (code: Record<string, string>) => void;
    onCodeRun?: (previewContent: string, output: string, executionTime?: string, isRunning?: boolean) => void;
}
⋮----
// Add interface for the ref methods
export interface CodeEditorViewHandle {
    getCurrentCode: () => Record<string, string>;
}
⋮----
// Preview component that can be used in a separate column
export interface CodePreviewProps {
    isRunning: boolean;
    previewContent: string;
    output: string;
    isWebPreview: boolean;
    executionTime?: string;
    onClear?: () => void;
    onBack?: () => void;
    isMobileView?: boolean;
}
⋮----
// Reset loading state when new content is provided
⋮----
// Format console output with syntax highlighting
const formatConsoleOutput = (text: string) =>
⋮----
// Replace [ERROR], [WARN], and [INFO] tags with styled spans
⋮----
// Create a modified HTML content with a loading indicator
⋮----
<svg width="64" height="64" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
⋮----
// Calculate average age
⋮----
// Find oldest team member
⋮----
// Map language to Monaco editor language identifiers
⋮----
'react': 'javascript', // React uses JavaScript syntax with JSX
⋮----
// Prettier language display names
⋮----
// Judge0 language IDs - see https://judge0.com/
⋮----
'python': 71,      // Python 3.8.1
'sql': 82,         // SQL (SQLite 3.27.2)
'javascript': 63,  // JavaScript (Node.js 12.14.0)
'nodejs': 63,      // Node.js 12.14.0
⋮----
// Judge0 API URL - using environment variables for flexibility
⋮----
// Whether to use proxy approach to avoid CORS issues
⋮----
// Check if React is in the original languages array
⋮----
// When only React is selected, don't normalize languages (skip the mapping to JavaScript)
⋮----
// When React is the only language, skip normalization and just use React
⋮----
// When Node.js is the only language, skip normalization and just use Node.js
⋮----
// Otherwise normalize languages as usual
⋮----
// Remove duplicates
⋮----
// Ensure we have a default content for this language
⋮----
// Helper method to setup code state with defaults
const setupCodeState = (initial: Record<string, string>): Record<string, string> =>
⋮----
// Add entries for all valid languages
⋮----
// Initialize code state with provided initialCode or defaults
⋮----
// State for the active language tab
⋮----
// Preview state
⋮----
// Input state (for languages that need stdin)
⋮----
// Reset active language when languages prop changes
⋮----
// Mobile preview state
⋮----
// Check if web preview is available (HTML, CSS, JS)
⋮----
// Add state for input validation and toast
⋮----
// Check if we're on a mobile device
⋮----
// Effect to detect mobile devices
⋮----
const checkMobileView = () =>
⋮----
// Initial check
⋮----
// Listen for window resize events
⋮----
// Cleanup event listener
⋮----
// Auto-close toast after 5 seconds
⋮----
// Cleanup the timer when component unmounts or showToast changes
⋮----
// Update code state when initialCode changes
⋮----
// Handle code change for the active language
const handleCodeChange = (value: string | undefined) =>
⋮----
// Handle mobile back button click
const handleMobileBackClick = () =>
⋮----
// Notify parent that preview was closed
⋮----
// Signal that the preview is closed with empty content
// This doesn't clear the actual content but just signals UI state change
⋮----
// Function to count the number of input() calls in Python code
const countPythonInputs = (code: string): number =>
⋮----
// Match different variations of input calls
// This regex matches:
// 1. Standard input() calls
// 2. input("prompt") with any string prompt
// 3. Assigned input() calls like x = input()
// 4. Complex variations like x = int(input())
⋮----
// Remove comments first
⋮----
// Look for different input patterns
⋮----
/\binput\s*\([^)]*\)/g,               // Standard input() or input("prompt")
⋮----
// Count all occurrences of input calls
⋮----
// Count all occurrences, not just unique ones
⋮----
// Function to count the number of provided inputs
const countProvidedInputs = (input: string): number =>
⋮----
// Count all lines
⋮----
// Handle code run with input validation
const handleCodeRun = () =>
⋮----
setInputError(false); // Reset input error state
⋮----
// Check for Python input validation
⋮----
// If inputs are required but input panel is not open, show it
⋮----
setInputError(true); // Add error state when automatically opening input panel
⋮----
return; // Don't run code yet
⋮----
// If insufficient inputs, show error
⋮----
return; // Don't run code with insufficient inputs
⋮----
// If on mobile, show the preview
⋮----
// For React code
⋮----
// Create a basic HTML template with React and ReactDOM loaded from CDN with specific version
⋮----
// Notify parent component
⋮----
// Delay setting isRunning to false to give time for the iframe to start loading
⋮----
// Update parent again when loading is complete
⋮----
// For web-based languages, create a preview
⋮----
// For SQL, we'll handle the preview later in executeWithJudge0
⋮----
// Generate HTML preview with CSS and JavaScript
⋮----
// Combine all content
⋮----
// Notify parent component
⋮----
// Delay setting isRunning to false to give time for the iframe to start loading
⋮----
// Update parent again when loading is complete
⋮----
// For non-web languages, execute the code if possible
⋮----
// Send all supported languages to Judge0, including JavaScript and Node.js
⋮----
// Notify parent component that code execution is starting
⋮----
// Pass isRunning=true to indicate execution has started
⋮----
// For other languages, show placeholder message
⋮----
// Notify parent component for other languages
⋮----
setExecutionTime(''); // Reset execution time on error
⋮----
// Notify parent component
⋮----
// Set isRunning to false in case of an error
⋮----
// Execute code using Judge0 API
const executeWithJudge0 = async (language: string, sourceCode: string) =>
⋮----
setExecutionTime(''); // Reset execution time when starting new execution
⋮----
// If on mobile, show the preview
⋮----
// Check if language is supported by Judge0
⋮----
// Prepare request data
⋮----
stdin: stdInput,  // Use the input from the input panel
⋮----
cpu_time_limit: 2,  // 2 seconds
⋮----
memory_limit: 128000, // 128MB
stack_limit: 64000,  // 64MB
⋮----
// Step 1: Create a submission (using proxy if needed)
// Using Next.js API route to proxy the request and avoid CORS issues
⋮----
// Step 2: Poll for results
⋮----
await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second
⋮----
// Using Next.js API route to proxy the request
⋮----
// Check if processing is complete
// 1 = In Queue, 2 = Processing, 3 = Accepted, 4+ = Various errors
⋮----
// Step 3: Handle the result
⋮----
// Build output based on what's available
⋮----
// For SQL results, create HTML table instead of showing raw output
⋮----
// Generate HTML table from SQL results
⋮----
// Check if there are query results (not just success messages from CREATE/INSERT)
⋮----
// Create HTML table preview content
⋮----
// Set preview content with styled table
⋮----
// Still set a minimal text output
⋮----
// Notify parent component with both HTML content and text output
⋮----
// Use true for isWebPreview
⋮----
// For non-query operations (CREATE, INSERT, etc.)
⋮----
// Show a message in the preview
⋮----
// Use true for isWebPreview
⋮----
// Empty result
⋮----
// Use true for isWebPreview
⋮----
// If table generation fails, fall back to regular output display
⋮----
// For non-SQL languages, use normal output display
⋮----
// Store execution time separately instead of adding to output
⋮----
// If no output was generated
⋮----
// For non-SQL languages, make sure to notify parent component with updated outputs
⋮----
// Only set isRunning to false after everything is complete
⋮----
setExecutionTime(''); // Reset execution time on error
⋮----
// Notify parent component
⋮----
// Set isRunning to false in case of an error
⋮----
// Submit the code
const handleSubmit = () =>
⋮----
// Monaco editor setup
const handleEditorDidMount = (editor: any, monaco: Monaco) =>
⋮----
// You can customize the editor here if needed
⋮----
// Get the correct Monaco editor language based on active language
const getMonacoLanguage = (lang: string) =>
⋮----
return 'javascript'; // React and Node.js use JavaScript syntax
⋮----
// Helper function to generate HTML table from SQL output
const generateTableFromSqlOutput = (sqlOutput: string): string =>
⋮----
// Split output into lines
⋮----
// Start building HTML table
⋮----
if (!line) continue; // Skip empty lines
⋮----
// Replace multiple spaces with a single delimiter
⋮----
// Handle NULL values with italic styling
⋮----
// Treat all rows the same - no special header row
⋮----
// Effect to notify parent when mobile preview changes
⋮----
// When mobile preview is shown/hidden, notify parent to help with layout adjustments
⋮----
// Use useImperativeHandle to expose getCurrentCode method
⋮----
{/* Toast notification for input validation */}
⋮----
{/* Mobile-specific styles */}
⋮----
{/* Mobile preview overlay when active */}
⋮----
{/* Language tabs */}
⋮----
{/* Show all language tabs */}
⋮----
{/* Mobile language tabs - more compact */}
⋮----
{/* Show all language tabs */}
⋮----
{/* Main editor area with potential split for input */}
⋮----
{/* Code editor */}
⋮----
{/* Input panel (conditionally shown) */}
⋮----
setStdInput(e.target.value);
setInputError(false); // Clear error on input change
⋮----
{/* Action buttons */}
⋮----
{/* Only show the input toggle for languages that typically need input */}
⋮----
// Focus the input textarea when showing

================
File: src/components/CohortCard.tsx
================
import Link from "next/link";
import { Trash2 } from "lucide-react";
import { useState } from "react";
import ConfirmationDialog from "./ConfirmationDialog";
⋮----
interface CohortCardProps {
    cohort: {
        id: number;
        name: string;
    };
    schoolId?: number | string;
    onDelete?: (cohortId: number) => void;
}
⋮----
export default function CohortCard(
⋮----
// Generate a unique border color based on the cohort id
const getBorderColor = () =>
⋮----
const handleDeleteClick = (e: React.MouseEvent) =>
⋮----
const handleDeleteConfirm = async () =>
⋮----
// Close the dialog after successful deletion
⋮----
// Call the onDelete callback if provided
⋮----
{/* Confirmation Dialog */}
⋮----
onCancel=

================
File: src/components/CohortCoursesLinkerDropdown.tsx
================
import { useState, useEffect, useRef } from "react";
import { BookOpen, X, Plus } from "lucide-react";
import Link from "next/link";
import { Course } from "@/types";
import DripPublishingConfig, { DripPublishingConfigRef } from "./DripPublishingConfig";
import { DripConfig } from "@/types/course";
⋮----
interface CohortCoursesLinkerDropdownProps {
    isOpen: boolean;
    onClose: () => void;
    availableCourses: Course[];
    totalSchoolCourses: number;
    isLoadingCourses: boolean;
    courseError: string | null;
    schoolId: string;
    cohortId: string;
    onCoursesLinked: (courses: Course[], dripConfig?: DripConfig) => void;
    onFetchAvailableCourses: () => void;
}
⋮----
// Initialize filtered courses when available courses change
⋮----
// Reset temp selected courses when dropdown opens
⋮----
// Handle clicks outside the dropdown
⋮----
function handleClickOutside(event: MouseEvent)
⋮----
const handleCourseSearch = (e: React.ChangeEvent<HTMLInputElement>) =>
⋮----
// Show all available courses that aren't temporarily selected
⋮----
// Filter by name AND exclude temp selected courses
⋮----
const selectCourse = (course: Course) =>
⋮----
// Check if already selected
⋮----
return; // Already selected, do nothing
⋮----
// Add to temporary selection
⋮----
// Remove from filtered courses immediately for better UX
⋮----
const removeTempCourse = (courseId: number, e?: React.MouseEvent) =>
⋮----
// Find the course to remove
⋮----
// Remove from temp selection
⋮----
// Add back to filtered courses if it matches the current search
⋮----
const handleAddSelectedCourses = async () =>
⋮----
// If no courses selected, just close the dropdown
⋮----
// Validate drip config if enabled
⋮----
// Clear temporary selection and close dropdown
⋮----
onClick=
⋮----
{/* Only show search when there are available courses */}
⋮----
{/* Show temporarily selected courses right below the search bar */}
⋮----
// School has no courses at all
⋮----
// All school courses are already in the cohort
⋮----
// All available courses have been temporarily selected
⋮----
// Search returned no results
⋮----
{/* Add button at the end of the list */}

================
File: src/components/CohortDashboard.tsx
================
import { useState, useEffect } from "react";
import Link from "next/link";
import { HelpCircle, ChevronRight, ArrowUp, ArrowDown, Search } from "lucide-react";
import Tooltip from "@/components/Tooltip";
import ClientLeaderboardView from "@/app/school/[id]/cohort/[cohortId]/leaderboard/ClientLeaderboardView";
import TaskTypeMetricCard from "@/components/TaskTypeMetricCard";
import { CohortWithDetails as Cohort, CohortMember } from "@/types";
⋮----
interface TaskTypeMetrics {
    completion_rate: number;
    count: number;
    completions: Record<string, number>;
}
⋮----
// Course metrics interface
interface CourseMetrics {
    average_completion: number;
    num_tasks: number;
    num_active_learners: number;
    task_type_metrics: {
        quiz?: TaskTypeMetrics;
        learning_material?: TaskTypeMetrics;
        exam?: TaskTypeMetrics;
    };
}
⋮----
interface CohortDashboardProps {
    cohort: Cohort;
    cohortId: string;
    schoolId: string;
    onAddLearners?: () => void;
}
⋮----
// State for course metrics
⋮----
// State for active course
⋮----
// State for sorting the student metrics table
⋮----
// State for search functionality
⋮----
// Handle column header click for sorting
const handleSort = (column: string) =>
⋮----
// Cycle through: asc -> desc -> null
⋮----
// New column selected, start with ascending
⋮----
const fetchCourseMetrics = async () =>
⋮----
// Use the active course or default to the first course if none is selected
⋮----
// Set initial active course when courses change
⋮----
// Add click outside handler for dropdown
⋮----
const handleClickOutside = (event: MouseEvent) =>
⋮----
// Fetch metrics when the component mounts, when cohort courses change, or when active course changes
⋮----
// Check if there are any learners in the cohort
⋮----
// If no learners, display placeholder
⋮----
// Switch to learners tab and open invite dialog if callbacks are provided
⋮----
// Get the active course object
⋮----
{/* Course title - only show if there's just one course */}
⋮----
{/* Course selector dropdown */}
⋮----
<svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 ml-2" viewBox="0 0 20 20" fill="currentColor">
⋮----
{/* Task Completion Rate - 75% width */}
⋮----
{/* Left column: Percentage number, vertically centered */}
⋮----
{/* Right column: Progress bar and task count */}
⋮----
{/* Task count below the progress bar */}
⋮----
{/* Active Learners - 25% width */}
⋮----
{/* Calculate the percentage of active learners */}
⋮----
// Determine font size based on digit count
⋮----
{/* Task Type Metrics - Ultra Simple Direct Cards */}
⋮----
{/* Empty state */}
⋮----
{/* Cards Layout */}
⋮----
// Calculate number of available task types
⋮----
// Render with the appropriate grid class based on count
⋮----
{/* Learning Material Card */}
⋮----
{/* Quiz Card */}
⋮----
{/* Right side - Leaderboard */}
⋮----
{/* Use ClientLeaderboardView */}
⋮----
{/* View All Leaderboard Button */}
⋮----
{/* Student Level Metrics Table */}
⋮----
{/* Search input */}
⋮----
onChange=
⋮----
{/* Student metrics table */}
⋮----
// Get all unique student IDs across all task types
⋮----
// Map student IDs to member info
⋮----
// Function to get completion percentage for a student and task type
const getCompletionPercentage = (studentId: string, taskType: 'learning_material' | 'quiz') =>
⋮----
// First filter by search query
⋮----
if (!query) return true; // If no search query, include all
⋮----
// Search by email (could be extended to other fields if needed)
⋮----
// Then sort if sorting is active
⋮----
// Handle null values (put them at the end)
⋮----
// Show empty state when no results match search
⋮----
// Calculate completion percentages for each task type
⋮----
// Helper function to get text color class based on completion percentage
const getColorClass = (completion: number | null) =>

================
File: src/components/CohortMemberManagement.tsx
================
import { useState, useEffect, useRef } from "react";
import { Trash2, Plus, Mail, Upload, X } from "lucide-react";
import ConfirmationDialog from "@/components/ConfirmationDialog";
import { CohortMember, CohortWithDetails as Cohort } from "@/types";
⋮----
interface EmailInput {
    id: string;
    email: string;
    error?: string;
}
⋮----
interface InviteModalProps {
    isOpen: boolean;
    onClose: () => void;
    onSubmit: (emails: string[]) => Promise<void>;
    submitButtonText: string;
    isSubmitting: boolean;
    role: 'learner' | 'mentor';
}
⋮----
interface CohortMemberManagementProps {
    cohort: Cohort;
    role: 'learner' | 'mentor';
    cohortId: string;
    schoolId: string;
    onShowToast: (title: string, description: string, emoji: string) => void;
    updateCohort: (updatedMembers: CohortMember[]) => void;
    openInviteDialog?: boolean;
    onInviteDialogClose?: () => void;
}
⋮----
// Effect to focus and scroll to newly added inputs
⋮----
// Focus the input
⋮----
// Scroll the container to show the new input
⋮----
// If the input is below the visible area, scroll to it
⋮----
}, 50); // Small delay to ensure the DOM is updated
⋮----
// Reset the newly added id
⋮----
const handleSubmit = async () =>
⋮----
// Reset the modal on success
⋮----
// Specific error toast comes from the parent handler
⋮----
// Effect to sync the internal state with the external control prop
⋮----
// Add state for selected members
⋮----
// Get filtered members based on role
⋮----
// Text content that changes based on role
⋮----
// Handle individual member selection
const handleMemberSelection = (member: CohortMember) =>
⋮----
// Check if this member is already selected
⋮----
// If selected, remove it; if not, add it
⋮----
// Handle "select all" functionality
const handleSelectAllMembers = (e: React.ChangeEvent<HTMLInputElement>) =>
⋮----
// Check if all members are selected
const areAllMembersSelected = () =>
⋮----
const handleDeleteMember = (member: CohortMember) =>
⋮----
// Add function to handle multiple members deletion
const handleDeleteSelectedMembers = () =>
⋮----
const confirmDeleteMember = async () =>
⋮----
// Updated to handle both single and multiple member deletion
⋮----
// Update the cohort state in the parent component
⋮----
// Show success toast with appropriate message based on number of members deleted
⋮----
// Show error toast
⋮----
// Do NOT re-throw; error already surfaced to user and tests expect silent failure
⋮----
const handleAddMembers = async (emails: string[]) =>
⋮----
// Show success toast based on role
⋮----
// Generic fallback message; override only when the error is meaningful
⋮----
// Re-throwing is fine for upstream logs, tests focus on toast; keep behaviour
⋮----
const addMembers = async (emails: string[], roles: string[]) =>
⋮----
// Try to extract more detailed error message from response
⋮----
// Use the specific detail message from the API
⋮----
// If parsing JSON fails, use default error message
⋮----
// Fetch updated cohort data to get the new members
⋮----
// Update the parent component with the new members
⋮----
const handleCloseInviteDialog = () =>
⋮----
checked=
⋮----
{/* Invite Modal */}
⋮----
{/* Delete Confirmation Dialog */}
⋮----
// Email validation utility function

================
File: src/components/ConfirmationDialog.tsx
================
import React from 'react';
import { X, Trash2 } from 'lucide-react';
⋮----
interface ConfirmationDialogProps {
    // Core props (required)
    onConfirm: () => void;
    onCancel: () => void;
    onClickOutside?: () => void;
    // Visibility prop (with two possible names for backward compatibility)
    open?: boolean;
    show?: boolean;

    // Content props
    title?: string;
    message?: string;

    // Button text props
    confirmButtonText?: string;
    cancelButtonText?: string;

    // State props
    isLoading?: boolean;
    errorMessage?: string | null;

    // Type props for styling
    type?: 'publish' | 'delete' | 'custom' | 'save';

    // Custom content to be rendered between message and buttons
    children?: React.ReactNode;

    // Close button props
    showCloseButton?: boolean;
    onClose?: () => void;
}
⋮----
// Core props (required)
⋮----
// Visibility prop (with two possible names for backward compatibility)
⋮----
// Content props
⋮----
// Button text props
⋮----
// State props
⋮----
// Type props for styling
⋮----
// Custom content to be rendered between message and buttons
⋮----
// Close button props
⋮----
// Use either open or show prop for visibility
⋮----
// Content props with defaults
⋮----
// Action handlers
⋮----
// Button text with defaults
⋮----
// State props
⋮----
// Type with default
⋮----
// Custom content
⋮----
// Close button props
⋮----
// Handle both 'open' and 'show' props for backward compatibility
⋮----
// Default values based on type
⋮----
// Use provided values or defaults
⋮----
// Button styles based on type
⋮----
'bg-blue-600 hover:bg-blue-700'; // Default for custom type
⋮----
// Handle close button click
const handleClose = () =>
⋮----
{/* Render custom content if provided */}
⋮----
e.stopPropagation();
onCancel();

================
File: src/components/CourseCard.tsx
================
import Link from "next/link";
import { useParams } from "next/navigation";
import { Trash2 } from "lucide-react";
import { useState } from "react";
import ConfirmationDialog from "./ConfirmationDialog";
⋮----
interface CourseCardProps {
    course: {
        id: string | number;
        title: string;
        role?: string;
        org_id?: number;
        cohort_id?: number;
        org?: {
            slug: string;
        };
    };
    onDelete?: (courseId: string | number) => void;
}
⋮----
// Generate a unique border color based on the course id
const getBorderColor = () =>
⋮----
// Handle string IDs by converting to a number
⋮----
// Use string hash code
⋮----
// Ensure positive number
⋮----
// Determine the correct link path
const getLinkPath = () =>
⋮----
// If this is being viewed by a learner, use the school slug path
⋮----
// Include course_id and cohort_id as query parameters to help with selection on the school page
⋮----
// If we have an org_id from the API, use that for the school-specific course path
⋮----
// If we're in a school context, use the school-specific course path
⋮----
// Otherwise use the general course path
⋮----
// Check if this is an admin view
⋮----
const handleDeleteClick = (e: React.MouseEvent) =>
⋮----
const handleDeleteConfirm = async () =>
⋮----
// Close the dialog after successful deletion
⋮----
// Call the onDelete callback if provided
⋮----
<Link href=

================
File: src/components/CourseCohortSelectionDialog.tsx
================
import { useRef, useState, useEffect } from 'react';
import { X, Check } from 'lucide-react';
import Link from 'next/link';
import CreateCohortDialog from './CreateCohortDialog';
import DripPublishingConfig, { DripPublishingConfigRef } from './DripPublishingConfig';
import { DripConfig } from '@/types/course';
⋮----
// Define interface for CourseCohortSelectionDialog props
interface CourseCohortSelectionDialogProps {
    isOpen: boolean;
    onClose: () => void;
    originButtonRef: React.RefObject<HTMLButtonElement | null>;
    isPublishing: boolean;
    onConfirm: () => void;
    showLoading: boolean;
    hasError: boolean;
    errorMessage: string;
    onRetry: () => void;
    cohorts: any[]; // Using any[] for consistency with existing cohorts state
    selectedCohort: any | null; // Changed from tempSelectedCohorts to single selection
    onSelectCohort: (cohort: any) => void;
    onSearchChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
    searchQuery: string;
    filteredCohorts: any[];
    totalSchoolCohorts: number;
    schoolId: string;
    courseId?: string; // Add courseId for linking the new cohort
    onCohortCreated?: (cohort: any) => void; // Callback when a cohort is created and linked
    onOpenCreateCohortDialog: () => void; // New callback to open the CreateCohortDialog
    onAutoCreateAndPublish: () => void; // New callback for auto-creating cohort and publishing
    onDripConfigChange: (config: DripConfig | undefined) => void;
}
⋮----
cohorts: any[]; // Using any[] for consistency with existing cohorts state
selectedCohort: any | null; // Changed from tempSelectedCohorts to single selection
⋮----
courseId?: string; // Add courseId for linking the new cohort
onCohortCreated?: (cohort: any) => void; // Callback when a cohort is created and linked
onOpenCreateCohortDialog: () => void; // New callback to open the CreateCohortDialog
onAutoCreateAndPublish: () => void; // New callback for auto-creating cohort and publishing
⋮----
// Add CohortSelectionDialog component
⋮----
// Calculate position when button or isOpen changes
⋮----
const updatePosition = () =>
⋮----
// Position dropdown below button
// Use viewport-relative position (since fixed positioning is relative to viewport)
⋮----
// Calculate left position to avoid going off-screen
// Default to aligning with left edge of button
⋮----
// If dropdown would go off right edge, align with right edge of button instead
const dropdownWidth = 400; // Width of dropdown from CSS
⋮----
// Apply the new position directly to the DOM element for immediate effect
⋮----
// Initial position update
⋮----
// Add scroll and resize event listeners
⋮----
// Add a more frequent position update for smoother following during scrolling
const intervalId = setInterval(updatePosition, 16); // ~60fps
⋮----
// Handle clicks outside of the dropdown
⋮----
function handleClickOutside(event: MouseEvent)
⋮----
// Update the click handler to use the new callback
const handleCreateCohortClick = (e: React.MouseEvent) =>
⋮----
const handleConfirm = () =>
⋮----
// Validate drip config if publishing and drip config is enabled
⋮----
onClick=
⋮----
{/* Add label at the top */}
⋮----
{/* Only show search when not loading */}
⋮----
{/* Only show search when there are available cohorts */}
⋮----
// School has no cohorts at all
⋮----
// All cohorts have been assigned to the course already
⋮----
// Search returned no results
⋮----
{/* Scrollable cohorts list - limited to height of ~4 cohorts */}
⋮----
{/* Drip Publishing UI - Only show when publishing and a cohort is selected */}
⋮----
{/* Buttons always visible at bottom */}

================
File: src/components/CourseItemDialog.tsx
================
import { useRef, useEffect, useState } from "react";
import { Sparkles, Check, X, Pencil, Eye, Edit2, Zap } from "lucide-react";
import dynamic from "next/dynamic";
import { QuizQuestion } from "../types";
import type { LearningMaterialEditorHandle } from "./LearningMaterialEditor";
import type { QuizEditorHandle } from "../types";
import Toast from "./Toast";
import ConfirmationDialog from "./ConfirmationDialog";
import { TaskData } from "@/types";
import Tooltip from "./Tooltip";
import DatePicker from "react-datepicker";
⋮----
import { formatScheduleDate } from "@/lib/utils/dateFormat";
import { useAuth } from "@/lib/auth";
⋮----
// Dynamically import the editor components
⋮----
// Dynamically import the QuizEditor component
⋮----
// Define props interface for the component
interface CourseItemDialogProps {
    isOpen: boolean;
    activeItem: any; // Using any for now, should be properly typed
    activeModuleId: string | null;
    isEditMode: boolean;
    isPreviewMode: boolean;
    showPublishConfirmation: boolean;
    dialogTitleRef: React.RefObject<HTMLHeadingElement | null>;
    dialogContentRef: React.RefObject<HTMLDivElement | null>;
    onClose: () => void;
    onPublishConfirm: () => void;
    onPublishCancel: () => void;
    onSetShowPublishConfirmation: (show: boolean) => void;
    onSaveItem: () => void;
    onCancelEditMode: () => void;
    onEnableEditMode: () => void;
    onQuizContentChange: (questions: QuizQuestion[]) => void;
    focusEditor: () => void;
    schoolId?: string; // School ID for fetching scorecards
    courseId?: string; // Add courseId prop for learning materials
}
⋮----
activeItem: any; // Using any for now, should be properly typed
⋮----
schoolId?: string; // School ID for fetching scorecards
courseId?: string; // Add courseId prop for learning materials
⋮----
// Get authenticated user ID
⋮----
// Add refs for the editor components
⋮----
// Ref to store toast timeout ID
⋮----
// State to track preview mode for quizzes
⋮----
// State for scheduled date
⋮----
// Toast state
⋮----
// Add state for close confirmation dialog
⋮----
// Add a new state variable to track which type of confirmation is being shown
⋮----
// Add state for save confirmation dialog
⋮----
// State to track if quiz has questions (for publish/preview button visibility)
⋮----
// Add state for unsaved scorecard confirmation dialog
⋮----
// Use useRef instead of useState for storing the pending action
⋮----
// Add a ref for the date picker container
⋮----
// Initialize scheduledDate when activeItem changes
⋮----
// Function to validate scheduled date
const verifyScheduledDateAndSchedule = (date: Date | null) =>
⋮----
// Show error toast for dates in the past
⋮----
// Reset quiz preview mode when dialog is closed
⋮----
// Clear any active toast timeout when dialog closes
⋮----
// Reset toast state when dialog closes to prevent stuck toasts
⋮----
// Make sure to clear questions from active item when the dialog closes for draft quizzes
⋮----
// Reset toast state when dialog opens to prevent lingering toasts
⋮----
// When dialog opens, ensure hasQuizQuestions is correctly initialized
// For draft quizzes, always start with false (no questions)
⋮----
// Reset to false when dialog opens for draft quizzes
⋮----
// Also ensure activeItem.questions is cleared
⋮----
// For published quizzes, initialize based on actual data
// Will be updated when data is loaded by the QuizEditor
⋮----
// For materials, always true
⋮----
// Add a capture phase event listener for Escape key
⋮----
// Handler function for keydown events in the capture phase
const handleKeyDown = (e: KeyboardEvent) =>
⋮----
// If Escape key is pressed
⋮----
// Check for active dialog element to ensure dialog is actually open
⋮----
// If close confirmation is already showing, don't do anything
⋮----
// For published items in view mode, close directly
⋮----
// Prevent the default behavior and stop propagation
⋮----
// Check if there are actual changes
⋮----
// If we're in edit mode for a published item
⋮----
// Only show confirmation if there are changes
⋮----
// No changes, just exit edit mode
⋮----
// For draft items
// Check if the editor/quiz has any content using the appropriate ref
⋮----
// Check if the title has been changed from default
⋮----
// Set default title based on item type
⋮----
// If there's no content and title hasn't changed, close without confirmation
⋮----
// Only show confirmation if there are changes
⋮----
// No changes, just close
⋮----
// Add the event listener in the capture phase to intercept before other handlers
⋮----
// Clean up the event listener when the component unmounts or when dependencies change
⋮----
// Add a cleanup effect for the toast timeout when the component unmounts
⋮----
// Clean up toast timeout on unmount
⋮----
// Handle clicking outside of the date picker
⋮----
const handleClickOutside = (event: MouseEvent) =>
⋮----
// Bail early if dialog isn't open or there's no active item
⋮----
// Check if the quiz has questions using the local state variable
// For non-quiz items, this is always true
⋮----
// Function to handle closing the dialog
const handleCloseRequest = () =>
⋮----
// Check if there are actual changes
⋮----
// Case 1: Published learning material in edit mode
⋮----
// Only show confirmation if there are changes
⋮----
// For X button and backdrop click, we want to close the entire dialog after confirmation
// Use a different confirmation type to differentiate from the Cancel button
⋮----
// No changes, just close
⋮----
// Case 2: Draft items (check for content)
⋮----
// Check if the editor/quiz has any content using the appropriate ref
⋮----
// Check if the title has been changed from default
⋮----
// Set default title based on item type
⋮----
// If there's no content and title hasn't changed, close without confirmation
⋮----
// Only show confirmation if there are changes
⋮----
// Set confirmation type for draft items
⋮----
// No changes, just close
⋮----
// Add a handler for the Cancel button in published items' edit mode
const handleCancelEditClick = () =>
⋮----
// Check if there are actual changes
⋮----
// Only show confirmation if there are changes
⋮----
// Show confirmation for published items in edit mode
⋮----
// No changes, just exit edit mode
⋮----
const handleConfirmSaveDraft = () =>
⋮----
// Save logic for draft: call save and then close dialog
⋮----
// Handle confirmed close action
const handleConfirmDiscardChanges = () =>
⋮----
// For published items in edit mode, just exit edit mode without closing the dialog
⋮----
// Use the ref to call cancel directly to revert any changes
⋮----
// Use the ref to call cancel directly to revert any changes
⋮----
// Exit edit mode but keep the dialog open
⋮----
// For other confirmation types (draft items or X button click), close the entire dialog
⋮----
// Handle cancel close action
const handleCancelClosingDialog = () =>
⋮----
// Handle backdrop click to close dialog
const handleDialogBackdropClick = (e: React.MouseEvent) =>
⋮----
// Only close if clicking directly on the backdrop, not on the dialog content
⋮----
// Toggle quiz preview mode
const toggleQuizPreviewMode = () =>
⋮----
// If we're not already in preview mode and trying to enter it
⋮----
// Check if current question has content
⋮----
// Show toast notification
⋮----
return; // Prevent entering preview mode
⋮----
// Get the current question type and check for empty correct answer or missing scorecard
⋮----
// Show toast notification for missing coding languages
⋮----
return; // Prevent entering preview mode
⋮----
// For objective questions, check if correct answer is empty
⋮----
// Show toast notification for empty correct answer
⋮----
// Switch to answer tab
⋮----
return; // Prevent entering preview mode
⋮----
// For subjective questions, check if scorecard is set
⋮----
// Show toast notification for missing scorecard
⋮----
// Switch to scorecard tab
⋮----
return; // Prevent entering preview mode
⋮----
// Validate the scorecard criteria for subjective questions
// Get the current question's scorecard data
⋮----
// Use the shared validation function to validate the scorecard criteria
⋮----
return; // Prevent entering preview mode if validation fails
⋮----
// Toggle preview mode if content exists or we're exiting preview mode
⋮----
// Handle showing and hiding toast
const displayToast = (title: string, description: string, emoji: string = "🚀") =>
⋮----
// Clear any existing timeout to prevent premature closing of new toast
⋮----
// Set toast content
⋮----
// Set new timeout and store the ID for future reference
⋮----
}, 5000); // Auto-hide after 5 seconds
⋮----
// Handle save button click - show confirmation
const handleSaveClick = () =>
⋮----
// For quizzes, validate before showing save confirmation
⋮----
// Run validation before opening the save confirmation
⋮----
return; // Don't show confirmation if validation fails
⋮----
// For learning materials, validate content exists
⋮----
// Show error message
⋮----
return; // Don't show confirmation if validation fails
⋮----
// If validation passes, show save confirmation
⋮----
// Function to check for unsaved scorecard changes and handle appropriately
const checkUnsavedScorecardChangesBeforeAction = (action: () => void) =>
⋮----
// For quizzes, check for unsaved scorecard changes first
⋮----
// If no unsaved scorecard changes, proceed with the action
⋮----
// Handle unsaved scorecard confirmation - navigate to question
const handleGoBackToScorecard = () =>
⋮----
// Clear the pending action
⋮----
// Handle discard unsaved scorecard changes
const handleDiscardScorecardChanges = () =>
⋮----
// Execute the appropriate action based on what was being attempted
⋮----
// Clear the pending action
⋮----
// Handle confirmed save action
const handleConfirmSavePublished = () =>
⋮----
// Execute the actual save action based on item type
⋮----
// Use the ref to call save directly
⋮----
// Use the ref to call save directly
⋮----
// Handle cancel save action
const handleCancelSave = () =>
⋮----
{/* Dialog Header */}
⋮----
// For both learning materials and quizzes, allow editing title
// but don't propagate changes upward yet (will be handled during save)
// The current title will be stored in the DOM element
// and will be sent to the API during save/publish
⋮----
if (e.key === 'Enter')
⋮----
// Blur the element to trigger save
⋮----
// Prevent click from bubbling up
⋮----
// If not editable, don't continue
⋮----
// Set a flag to indicate the title is being edited
⋮----
// Only set cursor at the end on first click (not on double-click)
// This allows double-click to select text as expected
⋮----
// Set cursor position at the end of text
⋮----
// Reset the clicked flag after a short delay
⋮----
{/* Preview Mode Toggle for Quizzes/Exams */}
⋮----
{/* Publish button for all item types */}
⋮----
{/* Save Draft button */}
⋮----
{/* Existing Publish button */}
⋮----
// For quizzes, validate before showing publish confirmation
⋮----
// Run validation before opening the publish confirmation
⋮----
return; // Don't show confirmation if validation fails
⋮----
// For learning materials, validate content exists
⋮----
// Show error message
⋮----
return; // Don't show confirmation if validation fails
⋮----
// If validation passes, show publish confirmation
⋮----
onChange=
⋮----
minDate={new Date()} // Can't schedule in the past
⋮----
{/* Close button */}
⋮----
{/* Dialog Content */}
⋮----
style={{ height: 'calc(100vh - 65px)' }} // Adjust height to account for header
⋮----
// Ensure the click event doesn't bubble up
⋮----
// Only focus the editor if in editable mode
⋮----
// Focus the editor
⋮----
scheduledPublishAt=
⋮----
// Handle publish success
⋮----
// Properly update the UI state first
// This will transform the publish button to edit button
⋮----
// Add the scheduled_publish_at value from updatedData to activeItem
⋮----
// @ts-ignore - types may not perfectly match
⋮----
// Update will be handled by the parent component
⋮----
// Show toast notification
⋮----
// Hide the publish confirmation dialog
⋮----
onSaveSuccess=
⋮----
// Handle save success - similar to publish success but without status change
⋮----
// Update the activeItem with new title and content
⋮----
// Add the scheduled_publish_at value when saving
⋮----
// @ts-ignore - types may not perfectly match
⋮----
// Call the parent's save function
⋮----
// Show toast notification for save success
⋮----
// Track if there are questions for publish/preview button visibility
setHasQuizQuestions(questions.length > 0);
⋮----
// Keep activeItem.questions updated for component state consistency
if (activeItem)
⋮----
// Notify parent component
onQuizContentChange(questions);
⋮----
// Display toast notification for validation errors during publishing
⋮----
// Handle save success
⋮----
// Update the activeItem with the updated title and questions
⋮----
// Add the scheduled_publish_at value when saving
⋮----
// Call onSaveItem to exit edit mode
⋮----
// Show toast notification for save success
⋮----
// Handle publish success
⋮----
// Properly update the UI state first
// Properly update the UI state first
// This will transform the publish button to edit button
⋮----
// Add the scheduled_publish_at value from updatedData to activeItem
⋮----
// Update will be handled by the parent component
// Pass the updated data to the parent component
⋮----
// Show toast notification
⋮----
// Hide the publish confirmation dialog
⋮----
{/* Close confirmation dialog */}
⋮----
{/* Save confirmation dialog */}
⋮----
{/* Unsaved scorecard confirmation dialog */}
⋮----
{/* Toast notification */}

================
File: src/components/CourseModuleList.tsx
================
import { useState, useRef, useEffect } from "react";
import { ChevronUp, ChevronDown, ChevronRight, ChevronDown as ChevronDownExpand, Plus, HelpCircle, Trash, Clipboard, Check, Loader2, Copy, FileText, Brain, BookOpen, PenSquare, FileQuestion, ClipboardList, Lock, Ban } from "lucide-react";
import { Module, ModuleItem, Quiz } from "@/types/course";
import { QuizQuestion } from "@/types/quiz"; // Import from types instead
import CourseItemDialog from "@/components/CourseItemDialog";
import ConfirmationDialog from "@/components/ConfirmationDialog";
import Tooltip from "@/components/Tooltip"; // Import the Tooltip component
import { formatScheduleDate } from "@/lib/utils/dateFormat"; // Import the utility function
⋮----
interface CourseModuleListProps {
    modules: Module[];
    mode: 'edit' | 'view'; // 'edit' for teacher editing, 'view' for learner viewing
    onToggleModule: (moduleId: string) => void;
    onOpenItem?: (moduleId: string, itemId: string) => void;
    onMoveItemUp?: (moduleId: string, itemId: string) => void;
    onMoveItemDown?: (moduleId: string, itemId: string) => void;
    onDeleteItem?: (moduleId: string, itemId: string) => void;
    onAddLearningMaterial?: (moduleId: string) => Promise<void>;
    onAddQuiz?: (moduleId: string) => Promise<void>;
    onMoveModuleUp?: (moduleId: string) => void;
    onMoveModuleDown?: (moduleId: string) => void;
    onDeleteModule?: (moduleId: string) => void;
    onEditModuleTitle?: (moduleId: string) => void;
    expandedModules?: Record<string, boolean>; // For learner view
    saveModuleTitle?: (moduleId: string) => void; // Function to save module title
    cancelModuleEditing?: (moduleId: string) => void; // Function to cancel module title editing
    completedTaskIds?: Record<string, boolean>; // Added prop for completed task IDs
    completedQuestionIds?: Record<string, Record<string, boolean>>; // Add prop for partially completed quiz questions
    schoolId?: string; // Add school ID for fetching scorecards
    courseId?: string; // Add courseId for fetching learning materials

    // Dialog-related props
    isDialogOpen?: boolean;
    activeItem?: ModuleItem | null;
    activeModuleId?: string | null;
    isEditMode?: boolean;
    isPreviewMode?: boolean;
    showPublishConfirmation?: boolean;
    handleConfirmPublish?: () => void;
    handleCancelPublish?: () => void;
    closeDialog?: () => void;
    saveItem?: () => void;
    cancelEditMode?: () => void;
    enableEditMode?: () => void;
    handleQuizContentChange?: (questions: QuizQuestion[]) => void;
    setShowPublishConfirmation?: (show: boolean) => void;
    onDuplicateItem?: (moduleId: string, taskData: any, ordering: number) => Promise<void>;
}
⋮----
mode: 'edit' | 'view'; // 'edit' for teacher editing, 'view' for learner viewing
⋮----
expandedModules?: Record<string, boolean>; // For learner view
saveModuleTitle?: (moduleId: string) => void; // Function to save module title
cancelModuleEditing?: (moduleId: string) => void; // Function to cancel module title editing
completedTaskIds?: Record<string, boolean>; // Added prop for completed task IDs
completedQuestionIds?: Record<string, Record<string, boolean>>; // Add prop for partially completed quiz questions
schoolId?: string; // Add school ID for fetching scorecards
courseId?: string; // Add courseId for fetching learning materials
⋮----
// Dialog-related props
⋮----
saveModuleTitle = () => { }, // Default empty function
cancelModuleEditing = () => { }, // Default empty function
completedTaskIds = {}, // Default empty object for completed task IDs
completedQuestionIds = {}, // Default empty object for completed question IDs
⋮----
// Dialog-related props
⋮----
// Track completed items - initialize with completedTaskIds prop
⋮----
// State to track module deletion confirmation
⋮----
// State to track deletion in progress
⋮----
// State to track module deletion in progress
⋮----
// State to track task deletion confirmation
⋮----
// States to track module swapping in progress
⋮----
// States to track task swapping in progress
⋮----
// State to track task duplication in progress
⋮----
// Update completedItems when completedTaskIds changes
⋮----
// Only update the state if the values are actually different
// This prevents an infinite update loop
⋮----
// Refs for the dialog
⋮----
// Function to focus the editor
const focusEditor = () =>
⋮----
// First, blur the title element
⋮----
// Then try to find and focus the editor
⋮----
return; // Exit once we've focused an element
⋮----
// Function to handle swapping modules via API
const swapModules = async (moduleId1: string, moduleId2: string) =>
⋮----
// Function to handle swapping tasks via API
const swapTasks = async (taskId1: string, taskId2: string) =>
⋮----
// Function to handle moving a module up (with API call)
const handleMoveModuleUp = async (moduleId: string) =>
⋮----
// Find the module and its index
⋮----
if (index <= 0) return; // Can't move up if it's the first one
⋮----
// Get the previous module
⋮----
// Set loading state
⋮----
// Call the API to swap modules
⋮----
// Update UI via the parent component's handler
⋮----
// Could add a toast notification here
⋮----
// Clear loading state
⋮----
// Function to handle moving a module down (with API call)
const handleMoveModuleDown = async (moduleId: string) =>
⋮----
// Find the module and its index
⋮----
if (index === -1 || index === modules.length - 1) return; // Can't move down if it's the last one
⋮----
// Get the next module
⋮----
// Set loading state
⋮----
// Call the API to swap modules
⋮----
// Update UI via the parent component's handler
⋮----
// Could add a toast notification here
⋮----
// Clear loading state
⋮----
// Function to handle moving a task up (with API call)
const handleMoveTaskUp = async (moduleId: string, taskId: string) =>
⋮----
// Find the module
⋮----
// Find the task and its index
⋮----
if (index <= 0) return; // Can't move up if it's the first one
⋮----
// Get the previous task
⋮----
// Set loading state
⋮----
// Call the API to swap tasks
⋮----
// Update UI via the parent component's handler
⋮----
// Could add a toast notification here
⋮----
// Clear loading state
⋮----
// Function to handle moving a task down (with API call)
const handleMoveTaskDown = async (moduleId: string, taskId: string) =>
⋮----
// Find the module
⋮----
// Find the task and its index
⋮----
if (index === -1 || index === module.items.length - 1) return; // Can't move down if it's the last one
⋮----
// Get the next task
⋮----
// Set loading state
⋮----
// Call the API to swap tasks
⋮----
// Update UI via the parent component's handler
⋮----
// Could add a toast notification here
⋮----
// Clear loading state
⋮----
// Get the appropriate expanded state based on mode
const getIsExpanded = (moduleId: string) =>
⋮----
// Function to format unlock date for display
const formatUnlockDate = (unlockAt: string) =>
⋮----
// Handle module click based on mode
const handleModuleClick = (e: React.MouseEvent, moduleId: string) =>
⋮----
// Find the module
⋮----
// Prevent clicking on locked modules
⋮----
// If in edit mode and module is in editing mode, don't toggle expansion
⋮----
// Prevent toggling if clicking on buttons
⋮----
// Function to handle task deletion with API call
const handleDeleteTask = async (moduleId: string, itemId: string) =>
⋮----
// Make the API call to delete the task
⋮----
// If the API call was successful, update the UI
⋮----
// You could add a toast notification here for the error
⋮----
// Function to handle task delete confirmation
const handleConfirmTaskDelete = () =>
⋮----
// Function to cancel task deletion
const handleCancelTaskDelete = () =>
⋮----
// Function to handle module delete confirmation
const handleConfirmModuleDelete = async () =>
⋮----
// Make the API call to delete the module (milestone)
⋮----
// If the API call was successful, update the UI
⋮----
// Could add a toast notification here for the error
⋮----
// Function to cancel module deletion
const handleCancelModuleDelete = () =>
⋮----
// Function to get item type name for display
const getItemTypeName = (type?: string) =>
⋮----
// Function to handle task duplication with API call
const handleDuplicateTask = async (moduleId: string, itemId: string) =>
⋮----
// Make the API call to duplicate the task
⋮----
// If the API call was successful, update the UI
⋮----
// You could add a toast notification here for the error
⋮----
{/* Module header with title and buttons */}
⋮----
e.stopPropagation();
// Prevent toggling locked modules
if (module.unlockAt) return;
⋮----
onToggleModule(module.id);
⋮----
aria-label=
⋮----
{/* Module action buttons - only in edit mode */}
⋮----
saveModuleTitle(module.id);
⋮----
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="mr-1">
⋮----
if (onEditModuleTitle)
onEditModuleTitle(module.id);
⋮----
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="mr-1">
⋮----
handleMoveModuleDown(module.id);
⋮----
setModuleToDelete(module.id);
⋮----
{/* Add expand/collapse button on the right side for view mode */}
⋮----
// Prevent toggling locked modules
⋮----
{/* Progress information and bar - shown differently based on expanded state */}
⋮----
{/* Module content - only visible when expanded */}
⋮----
{/* Enhanced visual distinction with color and better icons */}
⋮----
{/* Add a small generating indicator if the item is still being generated */}
⋮----
{/* Always display question count for quizzes (except drafts) */}
⋮----
{/* Item action buttons - only in edit mode */}
⋮----
handleDuplicateTask(module.id, item.id);
⋮----
handleMoveTaskUp(module.id, item.id);
⋮----
handleMoveTaskDown(module.id, item.id);
⋮----
if (onDeleteItem)
setTaskToDelete({
                                                                        moduleId: module.id,
                                                                        itemId: item.id,
                                                                        itemType: item.type
                                                                    });
⋮----
{/* Completion checkbox - only in view mode */}
⋮----
{/* Add item buttons - only in edit mode */}
⋮----
onClick=

================
File: src/components/CoursePublishSuccessBanner.tsx
================
import React, { useState } from 'react';
import { Copy, Check } from 'lucide-react';
⋮----
interface CoursePublishSuccessBannerProps {
    isOpen: boolean;
    onClose: () => void;
    cohortId: number | null;
    cohortName: string;
    schoolId: string;
    schoolSlug: string;
    courseCount?: number;
    courseNames?: string[];
    // Source indicates where the banner was triggered from
    source?: 'course' | 'cohort';
}
⋮----
// Source indicates where the banner was triggered from
⋮----
source = 'course' // Default to course page as the source
⋮----
// Determine message based on source
⋮----
// Generate the invite link
⋮----
// Reset the copied state after 2 seconds
⋮----
{/* Main Modal Container */}
⋮----
{/* Left panel - Icon */}
⋮----
{/* Subtle animated background */}
⋮----
<svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg" className="w-full h-full opacity-30">
⋮----
{/* Checkmark with ripple effect */}
⋮----
<svg width="40" height="40" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
⋮----
{/* Ripple effect */}
⋮----
{/* Right panel - Text */}
⋮----
{/* Buttons */}
⋮----
{/* Copy Invite Link Button */}
⋮----
{/* Back Button */}
⋮----
{/* Animations */}

================
File: src/components/CreateCohortDialog.tsx
================
import React, { useState, useEffect, useCallback, useRef } from 'react';
import DripPublishingConfig, { DripPublishingConfigRef } from './DripPublishingConfig';
import { DripConfig } from '@/types/course';
⋮----
interface CreateCohortDialogProps {
    open: boolean;
    onClose: () => void;
    onCreateCohort: (cohort: any, dripConfig?: DripConfig) => void;
    schoolId?: string;
    showDripPublishSettings?: boolean;
}
⋮----
// Reset form state when dialog is opened
⋮----
const handleSubmit = async () =>
⋮----
// Validate cohort name
⋮----
// Validate drip config if enabled and showDripPublishSettings is true
⋮----
// Set loading state to true
⋮----
// Make API call to create cohort
⋮----
// Handle API errors
⋮----
// Get the new cohort data
⋮----
// Pass the created cohort back to the parent with drip config if applicable
⋮----
// Reset form state
⋮----
{/* Dialog Content */}
⋮----
{/* Conditionally render DripPublishingConfig */}
⋮----
{/* Dialog Footer */}

================
File: src/components/CreateCourseDialog.tsx
================
import React, { useState, useEffect } from 'react';
import { X } from 'lucide-react';
⋮----
interface CreateCourseDialogProps {
    open: boolean;
    onClose: () => void;
    onSuccess?: (courseData: { id: string; name: string }) => void;
    schoolId?: string | number;
}
⋮----
// Reset form state when dialog is opened
⋮----
const handleSubmit = async () =>
⋮----
// Validate course name
⋮----
// Make API request to create course
⋮----
// Reset form
⋮----
// Call the success callback with the created course data
⋮----
{/* Dialog Content */}
⋮----
{/* Dialog Footer */}

================
File: src/components/DripPublishingConfig.tsx
================
import { useState, useEffect, forwardRef, useImperativeHandle } from "react";
import DatePicker from "react-datepicker";
⋮----
import { DripConfig } from "@/types/course";
import Toast from './Toast';
⋮----
interface DripPublishingConfigProps {
    onConfigChange?: (config: DripConfig | undefined) => void;
}
⋮----
export interface DripPublishingConfigRef {
    validateDripConfig: () => string | null;
}
⋮----
// Time units for frequency selection
⋮----
// Notify parent of config changes without validation
⋮----
const handleValidationError = (error: string) =>
⋮----
const handleCloseToast = () =>
⋮----
// Expose validation function to parent
⋮----
{/* Pill Toggle for Drip Publishing */}
⋮----
{/* Frequency Row: Every [number] [unit] */}
⋮----
{/* Combined Date and Time Picker */}
⋮----
{/* Toast notification */}

================
File: src/components/Dropdown.tsx
================
import React, { useState, useRef, useEffect, ReactNode } from 'react';
import Tooltip from './Tooltip';
⋮----
export interface DropdownOption {
    label: string;
    value: string;
    color: string;
    tooltip?: string;
}
⋮----
interface DropdownProps {
    icon?: ReactNode;
    title: string;
    options: DropdownOption[];
    selectedOption?: DropdownOption;
    selectedOptions?: DropdownOption[];
    onChange: (option: DropdownOption | DropdownOption[]) => void;
    disabled?: boolean;
    disabledTooltip?: string;
    multiselect?: boolean;
    placeholder?: string;
}
⋮----
// Determine which options are selected based on mode
⋮----
// Check if an option is selected (for multiselect mode)
const isSelected = (option: DropdownOption) =>
⋮----
const toggleDropdown = () =>
⋮----
if (disabled) return; // Don't toggle if disabled
⋮----
// Handle option selection based on mode
const handleOptionSelect = (option: DropdownOption, e?: React.MouseEvent) =>
⋮----
// Stop event propagation if provided to prevent dropdown from closing in multiselect mode
⋮----
// In multiselect mode, toggle the selection
⋮----
// Don't close dropdown in multiselect mode
⋮----
// In single select mode, select the option and close dropdown
⋮----
// Close dropdown when clicking outside
⋮----
function handleClickOutside(event: MouseEvent)
⋮----
// Render dropdown's selectable portion with optional tooltip if disabled
⋮----
{/* Option content */}
⋮----
onClick=
⋮----
{/* Tooltip content displayed directly under the option */}
⋮----
// If disabled and has disabled tooltip, wrap in tooltip
⋮----

================
File: src/components/dropdownOptions.ts
================
import { DropdownOption } from "./Dropdown";
⋮----
// Options for question purpose in the quiz editor
⋮----
// Options for question types in the quiz editor
⋮----
// Options for answer types in the quiz editor
⋮----
// Options for coding languages in the quiz editor

================
File: src/components/editor-styles.css
================
/* Dark mode styles for BlockNote editor */
⋮----
.dark-editor-container {
⋮----
/* Ensure the container has a dark background */
⋮----
/* Ensure editor container has a lower z-index than the dialog header */
⋮----
/* Override any light mode styles that might be applied */
.dark-editor {
⋮----
/* Ensure all text in the editor is visible in dark mode */
.dark-editor [data-content-type="text"] {
⋮----
/* Make placeholders more visible in dark mode */
.dark-editor [data-placeholder]::before {
⋮----
/* Ensure block backgrounds are dark */
.dark-editor [data-content-type="block"] {
⋮----
/* Style the toolbar and menus for dark mode */
.dark-editor .bn-container {
⋮----
.bn-container a {
⋮----
/* Ensure buttons and interactive elements have proper contrast */
.dark-editor button {
⋮----
.dark-editor button:hover {
⋮----
/* Fix for the white border at the bottom of the editor */
.dark-editor .ProseMirror {
⋮----
.dark-editor .ProseMirror>*:last-child {
⋮----
/* Fix for any bottom borders in the editor content */
.dark-editor .bn-editor,
⋮----
/* Dialog box styling */
[role="dialog"],
⋮----
/* Target Radix UI dialog specifically */
[data-radix-dialog-content],
⋮----
/* Target any parent dialog containers */
div[role="dialog"] {
⋮----
/* Ensure the dialog content has the right background */
div[role="dialog"]>div {
⋮----
/* Style for the BlockNote editor in dark mode */
.dark-editor-container .bn-container {
⋮----
/* Ensure BlockNote container respects the parent z-index */
⋮----
/* Style for the BlockNote toolbar in dark mode */
.dark-editor-container .bn-toolbar {
⋮----
/* Style for the BlockNote toolbar buttons in dark mode */
.dark-editor-container .bn-toolbar button {
⋮----
.dark-editor-container .bn-toolbar button:hover {
⋮----
/* Style for the BlockNote content in dark mode */
.dark-editor-container .bn-content {
⋮----
/* Style for the BlockNote dialog in dark mode */
.dark-dialog .mantine-Dialog-root {
⋮----
/* Segmented Control Styles */
.segmented-control-container {
⋮----
.segmented-control {
⋮----
.segmented-control-option {
⋮----
.segmented-control-option.active {
⋮----
.segmented-control-option:hover:not(.active) {
⋮----
/* Configuration Panel Styles */
.config-panel {
⋮----
.config-grid {
⋮----
.config-item {
⋮----
.config-item.full-width {
⋮----
.config-panel label {
⋮----
.config-panel select,
⋮----
.config-panel select {
⋮----
.config-panel select:hover,
⋮----
.config-panel select:focus,
⋮----
.config-panel textarea {
⋮----
.config-panel .help-text {
⋮----
/* Toggle button styles */
.toggle-config-btn {
⋮----
.toggle-config-btn:hover {
⋮----
.toggle-config-btn svg {
⋮----
/* Preview Panel Styles */
.preview-panel {
⋮----
.preview-panel h3 {
⋮----
.preview-content {
⋮----
.preview-placeholder {
⋮----
.preview-placeholder>p {
⋮----
.input-preview {
⋮----
.preview-question-content {
⋮----
.preview-question-content p {
⋮----
.preview-question-content .empty-content {
⋮----
/* Text Input Preview */
.text-input-field {
⋮----
.text-input-field textarea {
⋮----
/* Code Input Preview */
.code-input-field {
⋮----
.code-header {
⋮----
.code-area {
⋮----
/* Audio Input Preview */
.audio-input-field {
⋮----
.audio-record-button {
⋮----
.audio-duration {
⋮----
/* Fix for borders between blocks and the last block border */
.dark-editor [data-node-type="paragraph"],
⋮----
/* Ensure the last block has no border */
.dark-editor [data-node-type]:last-child {
⋮----
/* Remove any default white outlines and borders */
.dark-editor .ProseMirror:focus {
⋮----
/* Fix for the bottom padding/margin to eliminate any white space */
⋮----
/* Target the container element with no bottom border */
.no-bottom-border {
⋮----
.no-bottom-border>* {
⋮----
/* Target any potential border-bottom on the BlockNoteView container */
.dark-editor-container .bn-container,
⋮----
/* Fix for the default white borders in BlockNote */
.dark-editor :where(.bn-container, [data-node-type], .ProseMirror) {
⋮----
/* Ensure proper background color at the bottom of the editor */
.dark-editor .ProseMirror::after {
⋮----
/* Correct Answer Editor Styles */
.correct-answer-editor {
⋮----
/* Add z-index to ensure it stays on top when focused */
⋮----
/* Improve focus handling for the correct answer editor */
.correct-answer-editor .ProseMirror:focus {
⋮----
/* Ensure the correct answer editor is isolated from other editors */
.correct-answer-editor .bn-container {
⋮----
/* Hide all UI elements in the correct answer editor */
/* .correct-answer-editor .bn-container [role="toolbar"],
.correct-answer-editor .bn-toolbar,
.correct-answer-editor .bn-side-menu,
.correct-answer-editor .bn-slash-menu,
.correct-answer-editor .bn-file-panel,
.correct-answer-editor .bn-link-toolbar {
    display: none !important;
} */
⋮----
/* Make the correct answer editor more compact */
.correct-answer-editor .ProseMirror {
⋮----
/* Remove any extra spacing in the correct answer editor */
.correct-answer-editor [data-node-type="paragraph"] {
⋮----
/* Style the placeholder text */
.correct-answer-editor [data-placeholder]::before {
⋮----
/* Ensure the editor takes up the full height of its container */
.correct-answer-editor .bn-container,
⋮----
/* Make the quiz question editor have a max height with scroll */
.quiz-editor .ProseMirror {
⋮----
/* Make the quiz question viewer have a max height with scroll */
.quiz-viewer-preview .ProseMirror {
⋮----
.quiz-viewer .ProseMirror {
⋮----
/* Animation for validation error highlighting */
⋮----
/* Apply the animation to highlighted elements */
.animate-pulse {
⋮----
/* Additional styles for the quiz editor */
.editor-container {
⋮----
/* .editor-container:focus-within {
    box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
} */
⋮----
/* Media query for small screens - adjust padding for BlockNote editor */
⋮----
.bn-editor {
⋮----
/* DatePicker Dark Theme customization */
.react-datepicker {
⋮----
.react-datepicker__header {
⋮----
.react-datepicker__current-month,
⋮----
.react-datepicker__day {
⋮----
.react-datepicker__day:hover {
⋮----
.react-datepicker__day--selected,
⋮----
.react-datepicker__time-container {
⋮----
.react-datepicker__time-container .react-datepicker__time {
⋮----
.react-datepicker__time-container .react-datepicker__time-box ul.react-datepicker__time-list li.react-datepicker__time-list-item {
⋮----
.react-datepicker__time-container .react-datepicker__time-box ul.react-datepicker__time-list li.react-datepicker__time-list-item:hover {
⋮----
.react-datepicker__time-container .react-datepicker__time-box ul.react-datepicker__time-list li.react-datepicker__time-list-item--selected {
⋮----
.react-datepicker__triangle {
⋮----
.react-datepicker__triangle::before {
⋮----
.react-datepicker__navigation-icon::before,
⋮----
.react-datepicker__navigation:hover *::before {
⋮----
/* DatePicker input styling */
.react-datepicker-wrapper input:focus {

================
File: src/components/GenerateWithAIDialog.tsx
================
import { useState, useRef, Fragment, useEffect } from 'react';
import { Dialog, Transition } from '@headlessui/react';
import { X, Upload, File, ArrowLeft, ArrowRight, Check, AlertCircle } from 'lucide-react';
import { Document, Page } from 'react-pdf';
import { pdfjs } from 'react-pdf';
⋮----
// Set worker source using CDN (keeps the bundle smaller)
// Only set this in non-test environments to avoid import.meta.url issues
⋮----
// Fallback for environments that don't support import.meta.url
⋮----
interface GenerateWithAIDialogProps {
    open: boolean;
    onClose: () => void;
    onSubmit: (data: GenerateWithAIFormData) => void;
    validationError?: string | null;
}
⋮----
export interface GenerateWithAIFormData {
    courseDescription: string;
    intendedAudience: string;
    referencePdf: File | null;
    instructionsForAI: string;
}
⋮----
type Step = 'description' | 'audience' | 'reference' | 'instructions' | 'review';
⋮----
interface FormErrors {
    courseDescription?: string;
    intendedAudience?: string;
    referencePdf?: string;
}
⋮----
// Add form errors state
⋮----
// Track which step the user is currently on
⋮----
// Add inside the component, after the existing state declarations
⋮----
// Reset state when dialog is opened
const resetState = () =>
⋮----
const handleTextChange = (e: React.ChangeEvent<HTMLTextAreaElement>) =>
⋮----
// Clear error for this field when user types
⋮----
function onDocumentLoadSuccess(
⋮----
// Optionally remove the file if it's invalid
⋮----
// We're keeping the file since it's valid
⋮----
const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) =>
⋮----
// Reset previous validation errors
⋮----
// Check file type
⋮----
// Check file size (32MB = 32 * 1024 * 1024 bytes)
const maxSize = 32 * 1024 * 1024; // 32MB in bytes
⋮----
// Start validating
⋮----
// Update form data with the file - page count validation will happen separately
⋮----
// Clear error if it exists
⋮----
const triggerFileInput = () =>
⋮----
const removeFile = () =>
⋮----
const handleSubmit = async () =>
⋮----
// Call onSubmit (handleGenerateCourse) but don't wait for it
// since it handles its own state management
⋮----
// Immediately close the dialog and reset its state
⋮----
const validateCurrentStep = (): boolean =>
⋮----
const nextStep = () =>
⋮----
// Validate current step before proceeding
⋮----
// Move to next step based on current step
⋮----
const prevStep = () =>
⋮----
// Clear errors when going back
⋮----
// Move to previous step based on current step
⋮----
// Create a handler that completely ignores outside clicks
const handleDialogClose = () =>
⋮----
// Simple no-op function that ignores all outside clicks
const noop = () =>
⋮----
// Intentionally empty - this prevents the dialog from closing on outside clicks
⋮----
// Get step heading and description based on current step
const getStepContent = () =>
⋮----
// Calculate progress percentage
⋮----
{/* Progress bar */}
⋮----
{/* Close button */}
⋮----
{/* Description Step */}
⋮----
{/* Audience Step */}
⋮----
{/* Reference Material Step */}
⋮----
{/* Additional Instructions Step */}
⋮----
{/* Review Step */}
⋮----
{/* Step navigation buttons */}
⋮----
<div></div> // Empty div to maintain layout

================
File: src/components/InviteMembersDialog.tsx
================
import React, { useState, useEffect, useRef } from 'react';
import { X, Plus, Trash2, Mail } from 'lucide-react';
⋮----
interface InviteMembersDialogProps {
    open: boolean;
    onClose: () => void;
    onInvite: (emails: string[]) => void;
}
⋮----
// Reset state when dialog is opened
⋮----
// Update input refs array when number of rows changes
⋮----
// Scroll to bottom and focus new input when new email is added
⋮----
// Focus the last input if it exists
⋮----
// Email validation regex
⋮----
const validateEmail = (email: string): boolean =>
⋮----
const validateAllEmails = () =>
⋮----
const handleEmailChange = (index: number, value: string) =>
⋮----
// Update error for this specific email
⋮----
const addEmailRow = () =>
⋮----
const removeEmailRow = (index: number) =>
⋮----
const handleSubmit = () =>
⋮----
// Validate all emails
⋮----
// If there are any errors, don't proceed
⋮----
// Filter out any empty emails and submit
⋮----
{/* Dialog Content */}
⋮----
onChange=
onFocus=
onBlur=
⋮----
{/* Dialog Footer */}

================
File: src/components/LearnerCohortView.tsx
================
import React, { useState, useEffect, useCallback, useRef } from "react";
import LearnerCourseView from "./LearnerCourseView";
import LearningStreak from "./LearningStreak";
import TopPerformers from "./TopPerformers";
import { Module } from "@/types/course";
import { useAuth } from "@/lib/auth";
import { Course, Cohort } from "@/types";
import { ChevronDown } from "lucide-react";
import MobileDropdown, { DropdownOption } from "./MobileDropdown";
⋮----
// Constants for localStorage keys
⋮----
// Mobile tab options
enum MobileTab {
    Course = 'course',
    Progress = 'progress'
}
⋮----
interface LearnerCohortViewProps {
    courseTitle: string;
    modules: Module[];
    schoolId?: string;
    cohortId?: string;
    streakDays?: number;
    activeDays?: string[];
    completedTaskIds?: Record<string, boolean>;
    completedQuestionIds?: Record<string, Record<string, boolean>>;
    courses?: Course[];
    onCourseSelect?: (index: number) => void;
    activeCourseIndex?: number;
}
⋮----
interface StreakData {
    streak_count: number;
    active_days: string[]; // Format: YYYY-MM-DD
}
⋮----
active_days: string[]; // Format: YYYY-MM-DD
⋮----
// Add state to manage completed tasks and questions
⋮----
// State to track whether to show the TopPerformers component
⋮----
// State for mobile course dropdown
⋮----
// State for the active mobile tab
⋮----
// Add useEffect to update local state when props change
⋮----
// Add state for streak data
⋮----
// Get user from auth context
⋮----
// Use refs for last increment tracking to avoid dependency cycles
⋮----
// Load persisted values from localStorage when component mounts
⋮----
// Function to convert date to day of week abbreviation (S, M, T, W, T, F, S)
⋮----
const dayIndex = date.getDay(); // 0 is Sunday, 1 is Monday, etc.
⋮----
// Return unique identifiers for each day, with position index to distinguish Sunday (0) and Saturday (6)
// This allows us to still show "S" for both Saturday and Sunday in the UI,
// but have a way to uniquely identify them internally
⋮----
// Get today's date in YYYY-MM-DD format
⋮----
// Check if we already incremented streak today
⋮----
// Create a fetchStreakData function that can be reused
⋮----
// Only fetch if we have both user ID and cohort ID
⋮----
// Don't fetch if streak was already incremented today
⋮----
// Clear the initial load flag
⋮----
// Check if streak count has increased since last fetch
⋮----
// If streak has increased, save today as the last increment date
⋮----
// Save to localStorage
⋮----
// If streak has been incremented today, show the TopPerformers component
⋮----
// Update last streak count
⋮----
// Set streak count and active days in state
⋮----
// Keep existing values on error
⋮----
// Fetch streak data when component mounts or when dependencies change
⋮----
// Handle dialog close event to refresh streak data
⋮----
// Handler for task completion updates
⋮----
// If a task was completed, check for streak update after a small delay
⋮----
// Handler for question completion updates
⋮----
// Initialize the object for this task if it doesn't exist
⋮----
// Mark this question as complete
⋮----
// If a question was completed, check for streak update after a small delay
⋮----
// Determine if sidebar should be shown
⋮----
// Convert courses to dropdown options
⋮----
// Handle course selection
const handleCourseSelect = (index: number) =>
⋮----
// Handle course selection from dropdown
const handleCourseDropdownSelect = (option: DropdownOption<number>) =>
⋮----
// Callback for when TopPerformers has no data
⋮----
// Close dropdown when clicking outside
⋮----
function handleClickOutside(event: MouseEvent)
⋮----
const getActiveCourse = () =>
⋮----
// Clean up event listeners when component unmounts
⋮----
{/* Left Column: Course Tabs and Course Content */}
⋮----
{/* Course Selector */}
⋮----
{/* Desktop Tabs - Hidden on Mobile */}
⋮----
{/* Active indicator - visible only for active tab */}
⋮----
{/* Hover indicator - visible only on hover for inactive tabs */}
⋮----
{/* Mobile Course Selector - Visible only on small screens */}
⋮----
{/* Current course indicator */}
⋮----
{/* Mobile Dropdown using MobileDropdown component */}
⋮----
{/* Course Content */}
⋮----
{/* Right Column: Streak and Performers */}
⋮----
{/* Streak component when not loading and cohort ID exists */}
⋮----
{/* Only show TopPerformers if showTopPerformers is true */}
⋮----
// onEmptyData={handleEmptyPerformersData}
⋮----
{/* Mobile Bottom Tabs - Only visible on mobile */}

================
File: src/components/LearnerCourseView.tsx
================
import { useState, useRef, useCallback, useEffect } from "react";
import Link from "next/link";
import { ModuleItem, Module } from "@/types/course";
import CourseModuleList from "./CourseModuleList";
import dynamic from "next/dynamic";
import { X, CheckCircle, BookOpen, HelpCircle, Clipboard, ChevronLeft, ChevronRight, Menu, FileText, Brain, ClipboardList, Loader2 } from "lucide-react";
import { useAuth } from "@/lib/auth";
import confetti from "canvas-confetti";
import SuccessSound from "./SuccessSound";
import ModuleCompletionSound from "./ModuleCompletionSound";
import ConfirmationDialog from "./ConfirmationDialog";
⋮----
// Dynamically import viewer components to avoid SSR issues
⋮----
// Dynamic import for LearnerQuizView
⋮----
interface LearnerCourseViewProps {
    modules: Module[];
    completedTaskIds?: Record<string, boolean>;
    completedQuestionIds?: Record<string, Record<string, boolean>>;
    onTaskComplete?: (taskId: string, isComplete: boolean) => void;
    onQuestionComplete?: (taskId: string, questionId: string, isComplete: boolean) => void;
    onDialogClose?: () => void;
    viewOnly?: boolean;
    learnerId?: string;
    isTestMode?: boolean;
    isAdminView?: boolean;
}
⋮----
// Get user from auth context
⋮----
// Track completed tasks - initialize with props
⋮----
// Track completed questions within quizzes - initialize with structure that will be populated
⋮----
// Add state to track when task is being marked as complete
⋮----
// Add state for completedQuestionIds to manage the nested structure
⋮----
// Add a ref to track if we've added a history entry
⋮----
// Add state for success message
⋮----
// Add state for sound
⋮----
// Add state for module completion sound
⋮----
// Add state for AI responding status and confirmation dialog
⋮----
// Add state for mobile sidebar visibility
⋮----
// List of encouragement messages
⋮----
// Function to select a random encouragement message
const getRandomMessage = () =>
⋮----
// Update completedTasks when completedTaskIds prop changes
⋮----
// Update localCompletedQuestionIds when completedQuestionIds prop changes
⋮----
// Process completedQuestionIds into the format expected by this component
⋮----
// Convert the nested structure to a flat structure with keys like "questionId"
⋮----
// Filter out draft items from modules in both preview and learner view
⋮----
// Filter out empty modules (those with no items after filtering)
⋮----
// Calculate progress for each module based on completed tasks
⋮----
// Get the total number of items in the module
⋮----
// If there are no items, progress is 0
⋮----
// Count completed items in this module
⋮----
// Calculate progress percentage
⋮----
const toggleModule = (moduleId: string) =>
⋮----
// Handle browser history for dialog
⋮----
// Handler for back button
const handlePopState = (event: PopStateEvent) =>
⋮----
// If dialog is open, close it
⋮----
// If dialog is opened, add history entry
⋮----
// Cleanup
⋮----
// Function to close the dialog
const closeDialog = () =>
⋮----
// If AI is responding, show confirmation dialog
⋮----
// Proceed with closing
⋮----
// Reset sidebar state
⋮----
// Reset history entry flag when dialog is closed
⋮----
// Call the onDialogClose callback if provided
⋮----
// Function to handle navigation confirmation
const handleNavigationConfirm = () =>
⋮----
// Execute the pending navigation action
⋮----
// Function to cancel navigation
const handleNavigationCancel = () =>
⋮----
// Function to activate a specific question in a quiz or exam
const activateQuestion = (questionId: string) =>
⋮----
// Execute question activation (without checks)
const executeActivateQuestion = (questionId: string) =>
⋮----
// Function to open a task item and fetch its details
const openTaskItem = async (moduleId: string, itemId: string, questionId?: string) =>
⋮----
// Check if AI is responding and we're trying to open a different item
⋮----
// Execute open task item (without checks)
const executeOpenTaskItem = async (moduleId: string, itemId: string, questionId?: string) =>
⋮----
// Reset sidebar state when opening a new task
⋮----
// Find the item in the modules
⋮----
// Fetch item details from API
⋮----
// Create an updated item with the fetched data
⋮----
// Ensure questions have the right format for the QuizEditor component
⋮----
// Create a properly formatted question object
⋮----
blocks: q.blocks || [], // Keep the original blocks property
content: q.blocks || [], // Also add as content for compatibility
⋮----
// Set active question ID if provided, otherwise set to first question
⋮----
// Still open dialog with existing item data if fetch fails
⋮----
// Set first question as active if it's a quiz
⋮----
// Function to navigate to the next task
const goToNextTask = () =>
⋮----
// If AI is responding, show confirmation dialog
⋮----
// Execute go to next task (without checks)
const executeGoToNextTask = () =>
⋮----
// If this is a quiz with questions and not on the last question, go to next question
⋮----
// Go to next question
⋮----
// Otherwise, go to next task in module
⋮----
// Find the index of the current task in the module
⋮----
// Check if there's a next task in this module
⋮----
// Navigate to the next task in the same module
⋮----
// Function to navigate to the previous task
const goToPreviousTask = () =>
⋮----
// If AI is responding, show confirmation dialog
⋮----
// Execute go to previous task (without checks)
const executeGoToPreviousTask = () =>
⋮----
// If this is a quiz with questions and not on the first question, go to previous question
⋮----
// Go to previous question
⋮----
// Otherwise, go to previous task in module
⋮----
// Find the index of the current task in the module
⋮----
// Check if there's a previous task in this module
⋮----
// Navigate to the previous task in the same module
⋮----
// Function to check if a module is now fully completed
const checkModuleCompletion = (moduleId: string, newCompletedTasks: Record<string, boolean>) =>
⋮----
// Check if all items in the module are now completed
⋮----
// If all tasks are completed and there's at least one task, this is a module completion
⋮----
// Function to handle quiz answer submission
⋮----
// Mark the question as completed
⋮----
// Check if all questions in the current quiz are now completed
⋮----
// Also update the nested completedQuestionIds structure to match our UI display
⋮----
// Initialize the object for this task if it doesn't exist
⋮----
// Mark this question as complete
⋮----
// Notify parent component about question completion
⋮----
// If this is a single question quiz, mark the entire task as complete
⋮----
// Notify parent component about task completion
⋮----
// Check if this task completion has completed the entire module
⋮----
// This completes the module - trigger the enhanced celebration
⋮----
// Standard celebration for task completion
triggerConfetti(true); // Full celebration for single question quiz completion
⋮----
// For multi-question quiz, check if all questions are now completed
⋮----
// Notify parent component about task completion
⋮----
// Check if this task completion has completed the entire module
⋮----
// This completes the module - trigger the enhanced celebration
⋮----
// Standard celebration for task completion
triggerConfetti(true); // Full celebration for completing entire quiz
⋮----
// Trigger light confetti for individual question completion
triggerConfetti(false); // Light celebration for single question completion
⋮----
// Function to mark task as completed
const markTaskComplete = async () =>
⋮----
// Set loading state to true to show spinner
⋮----
// Store chat message for learning material completion
// This is similar to the chat message storage in LearnerQuizView
// but we only send a user message, not an AI response
⋮----
// Continue execution even if this fails - don't block the UI update
⋮----
// Create updated completed tasks state
⋮----
// Mark the task as completed in our local state
⋮----
// Call the onTaskComplete callback to notify parent component
⋮----
// Check if this task completion has completed the entire module
⋮----
// This completes the module - trigger the enhanced celebration
⋮----
// Regular completion celebration
⋮----
// Find the current module
⋮----
// Find the index of the current task in the module
⋮----
// Check if there's a next task in this module
⋮----
// Navigate to the next task in the same module
⋮----
// Reset loading state
⋮----
// Function to check if we're at the first task in the module
const isFirstTask = () =>
⋮----
// If this is a quiz with questions, check if we're on the first question
⋮----
// Not the first question, so return false
⋮----
// Function to check if we're at the last task in the module
const isLastTask = () =>
⋮----
// If this is a quiz with questions, check if we're on the last question
⋮----
// Not the last question, so return false
⋮----
// Handle Escape key to close dialog
const handleKeyDown = (e: React.KeyboardEvent<HTMLHeadingElement>) =>
⋮----
// Handle click outside dialog to close it
const handleDialogBackdropClick = (e: React.MouseEvent) =>
⋮----
// Only close if clicking directly on the backdrop, not on the dialog content
⋮----
// Function to get previous task info
const getPreviousTaskInfo = () =>
⋮----
// If this is a quiz with questions and not on the first question, get previous question info
⋮----
// Return previous question info
⋮----
// Get previous task in module
⋮----
// Find the index of the current task in the module
⋮----
// Return previous task info
⋮----
// Function to get next task info
const getNextTaskInfo = () =>
⋮----
// If this is a quiz with questions and not on the last question, get next question info
⋮----
// Return next question info
⋮----
// Get next task in module
⋮----
// Find the index of the current task in the module
⋮----
// Return next task info
⋮----
// Handle AI responding state change from quiz view
⋮----
// Function to trigger confetti animation
const triggerConfetti = (isFullCompletion = true) =>
⋮----
// Trigger confetti effect with different intensity based on completion type
⋮----
// Play success sound
⋮----
// Reset sound trigger after a short delay
⋮----
// Function to trigger a more extravagant confetti celebration for module completion
const triggerModuleCompletionCelebration = () =>
⋮----
// Get random confetti origin points for a more dynamic effect
const generateRandomOrigin = () => (
⋮----
x: 0.2 + Math.random() * 0.6, // Random x value between 0.2 and 0.8
y: 0.2 + Math.random() * 0.4  // Random y value between 0.2 and 0.6
⋮----
// First wave - center burst (larger particles)
⋮----
scalar: 1.5 // Larger particles
⋮----
// Second wave - left side burst (with gravity)
⋮----
// Third wave - right side burst (with gravity)
⋮----
// Fourth wave - random bursts for 2 seconds
⋮----
// Play the more impressive module completion sound
⋮----
// Reset sound trigger after the sound duration
⋮----
}, 2000); // Longer timeout for the longer sound
⋮----
// Initialize expandedModules from the isExpanded property of modules
⋮----
// Only set if there are any expanded modules to avoid unnecessary state updates
⋮----
// Toggle sidebar visibility for mobile
const toggleSidebar = () =>
⋮----
{/* Success Sound */}
⋮----
{/* Module Completion Sound */}
⋮----
{/* Navigation Confirmation Dialog */}
⋮----
{/* Task Viewer Dialog - Using the same pattern as the editor view */}
⋮----
onClick=
⋮----
{/* Mobile overlay - only shown when sidebar is open on mobile */}
⋮----
{/* Sidebar with module tasks - hidden on mobile by default */}
⋮----
{/* Sidebar Header */}
⋮----
{/* Close button for mobile sidebar */}
⋮----
{/* Task List */}
⋮----
// Check if there are any completed questions for this quiz
⋮----
{/* Add a small generating indicator if the item is still being generated */}
⋮----
// Match the same condition for the text color
⋮----
{/* Show questions as expanded items for active quiz */}
⋮----
{/* Back to Course Button - hidden on mobile, fixed at bottom for laptop */}
⋮----
{/* Main Content */}
⋮----
{/* Dialog Header */}
⋮----
// Add background color for completed tasks on mobile
⋮----
{/* Hamburger menu for mobile */}
⋮----
{/* Show completed status for learning material/quiz that has been completed */}
⋮----
{/* Mark Complete button for desktop */}
⋮----
{/* Dialog Content */}
⋮----
{/* Navigation Footer - Hidden on mobile */}
⋮----
{/* Mobile Navigation Footer - Only visible on mobile */}
⋮----
{/* Navigation Confirmation Dialog - Moved to end and z-index increased */}

================
File: src/components/LearnerQuizView.tsx
================
import { useState, useCallback, useRef, useEffect, useMemo } from "react";
import { ChevronLeft, ChevronRight, MoreVertical, Maximize2, Minimize2, MessageCircle, X, Columns, LayoutGrid, SplitSquareVertical, CheckCircle, Eye, EyeOff } from "lucide-react";
import BlockNoteEditor from "./BlockNoteEditor";
import { QuizQuestion, ChatMessage, ScorecardItem, AIResponse, QuizQuestionConfig } from "../types/quiz";
import ChatView, { CodeViewState, ChatViewHandle } from './ChatView';
import ScorecardView from './ScorecardView';
import ConfirmationDialog from './ConfirmationDialog';
import { getKnowledgeBaseContent } from './QuizEditor';
import { CodePreview } from './CodeEditorView';
import isEqual from 'lodash/isEqual';
import { safeLocalStorage } from "@/lib/utils/localStorage";
⋮----
// Add interface for mobile view mode
export interface MobileViewMode {
    mode: 'question-full' | 'chat-full' | 'split';
}
⋮----
export interface LearnerQuizViewProps {
    questions: QuizQuestion[];
    onSubmitAnswer?: (questionId: string, answer: string) => void;
    isDarkMode?: boolean;
    className?: string;
    viewOnly?: boolean;
    currentQuestionId?: string;
    onQuestionChange?: (questionId: string) => void;
    userId?: string;
    isTestMode?: boolean;
    taskId?: string;
    completedQuestionIds?: Record<string, boolean>;
    onAiRespondingChange?: (isResponding: boolean) => void;
    onMobileViewChange?: (mode: MobileViewMode) => void;
    isAdminView?: boolean;
}
⋮----
// Constant message for exam submission confirmation
⋮----
// Add state for tracking view mode
⋮----
// Current question index
⋮----
// Update current question index when currentQuestionId changes
⋮----
// Reset to chat view when changing questions
⋮----
// Ensure we have valid questions
⋮----
// Don't filter out any questions, just convert format if needed
⋮----
// If the question is null or undefined, return it with default empty values
⋮----
audioMaxDuration: 120, // Default to 2 minutes
⋮----
codingLanguages: [] // Default code language
⋮----
// If the question already has the right format, use it as is
⋮----
// Ensure config has all required properties with defaults
⋮----
codingLanguages: q.config?.codingLanguages || [] // Ensure code language is set
⋮----
// Handle API format where content might be in 'blocks' property
⋮----
codingLanguages: config.codingLanguages || [] // Ensure code language is set
⋮----
// Return a default structure for any other case
⋮----
codingLanguages: config.codingLanguages || [] // Ensure code language is set
⋮----
// Current answer input
⋮----
// State to track if an answer is being submitted
⋮----
// Modify the state to track chat history per question
⋮----
// State to track if AI is responding
⋮----
// State to track if chat history has been loaded
⋮----
// State to track if we should show the preparing report button
⋮----
// New state to track if we're viewing a scorecard
⋮----
// New state to track which scorecard we're viewing
⋮----
// Add state to remember chat scroll position
⋮----
// Add state for navigation confirmation dialog
⋮----
// Reference to the input element to maintain focus
⋮----
// Reference to the chat container for scrolling
⋮----
// Add a reference for the scorecard container
⋮----
// Reference to the ChatView component
⋮----
// Store the current answer in a ref to avoid re-renders
⋮----
// Store the handleSubmitAnswer function in a ref to avoid circular dependencies
⋮----
// Use a single state to track completed/submitted questions - initialize with props
⋮----
// Update completedQuestionIds when the prop changes
⋮----
// To avoid infinite update loops, only update if there are actual differences
⋮----
// State to track which questions are currently being submitted (waiting for API response)
⋮----
// Update the ref when the state changes
⋮----
// Effect to focus the input when the component mounts
⋮----
// Focus the input field when the component mounts
⋮----
// Reset chat history loaded state when taskId changes
⋮----
// Get the current question's chat history
⋮----
// For exam questions with existing chat history, we need to filter what's shown
⋮----
// Find any user messages in the history
⋮----
// Check if this question has a user message and is properly submitted (not currently in the submission process)
⋮----
// If we have user messages and the question is already submitted (not pending)
⋮----
// Get the last user message
⋮----
// If showing learner view, return only the last user message and confirmation
⋮----
// Otherwise return the full history to show AI feedback
⋮----
// Get the last user message for the current question
⋮----
// Filter for user messages only
⋮----
// Return the last user message if exists
⋮----
// Fetch chat history from backend when component mounts or task changes
⋮----
// Skip if we're in test mode or if userId is not available or if we've already loaded chat history
// Also skip if taskId is not provided
⋮----
const fetchChatHistory = async () =>
⋮----
// Make API call to fetch chat history using the provided taskId
⋮----
// Organize chat messages by question ID
⋮----
// Track which questions had user messages
⋮----
// Process messages sequentially with Promise.all for audio messages
⋮----
// For audio messages, fetch the actual audio data
⋮----
// Get presigned URL
⋮----
// Fetch the audio data using the presigned URL
⋮----
// Convert the audio data to base64
⋮----
// Convert API message to ChatMessage format
⋮----
// If this is an AI message, try to parse the content as JSON
⋮----
// Try to parse the content as JSON
⋮----
// Extract the feedback field to display as the message content
⋮----
// Extract scorecard if available
⋮----
// Extract is_correct if available
⋮----
// If parsing fails, assume it's the old format (plain text)
// Keep the original content as is - it's already set in chatMessage
⋮----
// Track questions with user responses for exam questions
⋮----
// Sort chat history by timestamp for each question to ensure correct order
⋮----
// Update chat histories state
⋮----
// For exam questions with responses, mark them as completed
⋮----
// Clear any pending submissions for these questions since they're loaded from history
⋮----
// Helper function to convert Blob to base64
const blobToBase64 = (blob: Blob): Promise<string> =>
⋮----
// Extract the base64 data portion (remove "data:audio/wav;base64," prefix)
⋮----
// Effect to focus the input when the question changes
⋮----
// Ensure the input is focused after a short delay to allow the DOM to fully render
⋮----
// Effect to log and validate questions when they change
⋮----
// Effect to scroll to the bottom of the chat when new messages are added
⋮----
// Navigate to previous question
⋮----
// If AI is responding, show confirmation dialog
⋮----
// Otherwise proceed with navigation
⋮----
// Execute navigation to previous question without checks
⋮----
setCurrentAnswer(""); // Reset answer when changing questions
// Reset to chat view when changing questions
⋮----
// Always notify parent component about question change
⋮----
// Navigate to next question
⋮----
// If AI is responding, show confirmation dialog
⋮----
// Otherwise proceed with navigation
⋮----
// Execute navigation to next question without checks
⋮----
setCurrentAnswer(""); // Reset answer when changing questions
// Reset to chat view when changing questions
⋮----
// Always notify parent component about question change
⋮----
// Handle navigation confirmation
⋮----
// Execute the navigation based on pending action
⋮----
// Handle navigation cancellation
⋮----
// Handle input change with focus preservation
⋮----
}, []); // No dependencies to ensure stability
⋮----
// Function to store chat history in backend
⋮----
// For quiz questions, use the completedQuestionIds state
⋮----
// For AI messages, check if it contains feedback about correctness
// We'll extract the is_correct value from the message if it exists
⋮----
// Try to parse the AI message as JSON to see if it contains is_correct
⋮----
// Get the response type from the current question config
⋮----
// Create content based on the response type
⋮----
// For report type, include both feedback and scorecard
⋮----
// For chat type or any other type, just include feedback
⋮----
// Process a user response (shared logic between text and audio submission)
⋮----
// Set submitting state to true
⋮----
// Create the user message object
⋮----
// Handle code type message differently for UI display
// Only set messageType to 'code' when it actually comes from the code editor
// or when the responseType is explicitly set to 'code'
⋮----
// Don't automatically convert text messages to code messages for coding questions
⋮----
// Immediately add the user's message to chat history
⋮----
// Clear the input field after submission (only for text input)
⋮----
// Focus the input field again
⋮----
// Special case: For exam questions in test mode, don't make the API call
// instead show confirmation immediately
⋮----
// Mark this question as completed
⋮----
// Call the onSubmitAnswer callback to mark completion
⋮----
// Add confirmation message immediately
⋮----
// Update chat history with confirmation message
⋮----
// Reset states
⋮----
return; // Skip the API call completely
⋮----
// For exam questions, mark as pending submission
⋮----
// Show the AI typing animation
⋮----
// Prepare the request body based on whether this is a teacher testing or a real learner
⋮----
// In teacher testing mode, send chat_history and question data
// Format the chat history for the current question
⋮----
// Create the request body for teacher testing mode
⋮----
// In normal mode, send question_id and user_id
⋮----
// Create a message ID for the streaming response
⋮----
// Create an initial empty message for streaming content
⋮----
// Track if we've received any feedback
⋮----
// For audio responses, get a presigned URL to upload the audio file
⋮----
// First, get a presigned URL for the audio file
⋮----
// Convert base64 audio data to a Blob
⋮----
// Create audio blob with WAV format
⋮----
// If we couldn't get a presigned URL, try direct upload to the backend
⋮----
// Create FormData for the file upload
⋮----
// Upload directly to the backend
⋮----
// Update the request body with the file information
⋮----
// Upload the audio file to S3 using the presigned URL
⋮----
// Upload to S3 using the presigned URL with WAV content type
⋮----
// Update the request body with the file information
⋮----
// Call the API with the appropriate request body for streaming response
⋮----
// Get the response reader for streaming for both exam and quiz
⋮----
// Function to process the streaming chunks
const processStream = async () =>
⋮----
// Add a variable to collect the complete scorecard
⋮----
// Add a flag to track if streaming is done
⋮----
// Convert the chunk to text
⋮----
// Split by newlines to handle multiple JSON objects in a single chunk
⋮----
// Handle feedback updates
⋮----
// Append to accumulated feedback
⋮----
// For practice questions, update the UI as we receive chunks
⋮----
// If this is the first feedback chunk we've received
⋮----
// Stop showing the animation
⋮----
// Add the AI message to chat history now that we have content
⋮----
// Update the existing AI message content for subsequent chunks
⋮----
// Find the current question's chat history
⋮----
// Find the index of the AI message to update
⋮----
// Update the existing message
⋮----
// For exam questions, we don't update the UI yet
// but we still track that we received feedback
⋮----
// Handle scorecard data when available
⋮----
// Show preparing report message if not already shown
⋮----
// Instead of immediately updating the chat message,
// collect the scorecard data
⋮----
// Handle is_correct when available - for practice questions
⋮----
// After processing all chunks (stream is complete)
⋮----
// Only now update the chat message with the complete scorecard
⋮----
// Check if all criteria received maximum scores
⋮----
// Set isCorrect to true only if all criteria have received their maximum score
⋮----
// Update the existing AI message with the complete scorecard data
⋮----
// Find the current question's chat history
⋮----
// Find the index of the AI message to update
⋮----
// Update the existing message with the complete scorecard
⋮----
// Only now hide the preparing report message
⋮----
// Mark this specific question as completed
⋮----
// Call the onSubmitAnswer callback to mark completion
⋮----
// Handle exam questions completion
⋮----
// Now that all chunks have been received, mark as complete
// Mark this question as completed
⋮----
// Call the onSubmitAnswer callback to mark completion
⋮----
// For exam questions, clear the pending submission status
⋮----
// Add exam confirmation message to chat history
⋮----
// Stop showing the AI responding animation for exam questions
⋮----
// Store chat history in backend for quiz
⋮----
// Only reset the preparing report state when an error occurs
// and we need to allow the user to try again
⋮----
// Start processing the stream for both exam and quiz
⋮----
// Show error message to the user
⋮----
// For exam questions, clear the pending status so the user can try again
⋮----
// Add the error message to the chat history
// This is only for UI display and won't be saved to the database
⋮----
// Reset report preparation state on error since the user needs to try again
⋮----
// Only reset submitting state when API call is done
⋮----
// If we never received any feedback, also reset the AI responding state
⋮----
// Add state for exam submission confirmation
⋮----
// Modified handleSubmitAnswer function to use shared logic
⋮----
// Get the current answer from the ref
⋮----
// For exam questions, show confirmation dialog
⋮----
// Use the shared processing function for non-exam questions
⋮----
// Handle exam submission confirmation
⋮----
// Handle exam submission cancellation
⋮----
// New function to handle audio submission using shared logic
⋮----
// Convert the WebM audio blob to WAV format
⋮----
// Convert AudioBuffer to WAV format
⋮----
// Convert the WAV blob to base64
⋮----
// Remove the data URL prefix (e.g., "data:audio/wav;base64,")
⋮----
// Use the shared processing function with audio-specific parameters
⋮----
// Helper function to convert AudioBuffer to WAV format
const convertAudioBufferToWav = (audioBuffer: AudioBuffer) =>
⋮----
// Extract channels
⋮----
// RIFF identifier
⋮----
// File length
⋮----
// RIFF type
⋮----
// Format chunk identifier
⋮----
// Format chunk length
⋮----
// Sample format (raw)
⋮----
// Channel count
⋮----
// Sample rate
⋮----
// Byte rate (sample rate * block align)
⋮----
// Block align (channel count * bytes per sample)
⋮----
// Bits per sample
⋮----
// Data chunk identifier
⋮----
// Data chunk length
⋮----
// Write PCM samples
⋮----
// Clamp the value to -1.0 - 1.0 range and convert to 16-bit
⋮----
// Helper function to write strings to DataView
const writeString = (view: DataView, offset: number, string: string) =>
⋮----
// Update the handleSubmitAnswerRef when handleSubmitAnswer changes
⋮----
// Get current question content
⋮----
// Get current question config
⋮----
// Focus the input field directly
⋮----
// Use requestAnimationFrame to ensure the DOM is fully rendered
⋮----
}, [currentQuestionIndex]); // Only re-focus when changing questions
⋮----
// Custom styles for hiding scrollbars
⋮----
// ScoreCard view toggle functions
const handleViewScorecard = (scorecard: ScorecardItem[]) =>
⋮----
// Save current chat scroll position before switching views
⋮----
// Reset scroll position of scorecard view when opened
⋮----
const handleBackToChat = () =>
⋮----
// Focus the input field when returning to chat if appropriate
⋮----
// Restore saved chat scroll position
⋮----
// Function to handle retrying the last user message
⋮----
// Find the most recent user message
⋮----
return; // No user message to retry
⋮----
// If in test mode, first remove the last user message and AI response
// Find all AI messages
⋮----
// If there are AI messages, remove the last user message and last AI message
⋮----
// Remove the last two messages (last user message and last AI response)
⋮----
// If no AI messages (unusual case), just remove the last user message
⋮----
// Remove just the last user message
⋮----
// Now process the user response again
// If it's an audio message, get the audio data
⋮----
// For text messages, resubmit the text content
⋮----
// Update the parent component when AI responding state changes
⋮----
// Add state for code view
⋮----
// Update the state with any code preview changes
const handleCodeStateChange = (newState: CodeViewState) =>
⋮----
// Remove the automatic view mode change when toggling between code and chat
// to preserve the user's selected view mode
⋮----
// On mobile, when preview content is first loaded for a code run,
// we still want to show it (but not when just toggling modes)
⋮----
// Only switch if this is a fresh code run, not just a mode toggle
⋮----
// When preview content is first set on mobile, automatically go to full chat view
// This ensures the preview is visible
⋮----
// Notify parent if needed
⋮----
// Determine if we should show the 3-column layout
⋮----
// Mobile view controls
⋮----
// Track if we should show the pulse animation
⋮----
// Track if button has completed entrance animation
⋮----
// Effect to start pulsing animation after entrance animation completes
⋮----
// Check if user has clicked the FAB before
⋮----
// If user has clicked before, don't show animations
⋮----
// For new users, start with entrance animation
⋮----
// Wait for entrance animation to complete before starting the pulse
⋮----
}, 800); // Match the duration of the entrance animation
⋮----
// Handle clicks outside the mobile menu to close it
⋮----
function handleClickOutside(event: MouseEvent)
⋮----
// Toggle mobile menu
const toggleMobileMenu = () =>
⋮----
// If the menu is being opened, stop the animation
⋮----
// Save to localStorage that user has clicked the button
⋮----
// Direct handler for changing view mode
const setViewMode = (mode: 'question-full' | 'chat-full' | 'split') =>
⋮----
// Apply CSS classes based on mode
⋮----
// Remove existing mode classes
⋮----
// Add current mode class
⋮----
}, [mobileViewMode, codeViewState.isViewingCode]); // Also reapply when code view toggle changes
⋮----
// Set initial showLearnerView based on isAdminView
⋮----
{/* Add the custom styles */}
⋮----
{/* Left side - Question (33% or 50% depending on layout) */}
⋮----
{/* Navigation controls at the top of left side - only show if more than one question */}
⋮----
{/* Use editor with negative margin to offset unwanted space */}
<div className="ml-[-60px]"> {/* Increased negative margin to align with navigation arrow */}
⋮----
onChange={() => { }} // Read-only in view mode
⋮----
{/* Middle column - Chat/Code View */}
⋮----
/* Use the ScorecardView component */
⋮----
/* Use the ChatView component */
⋮----
{/* Third column - Code Preview (only shown for coding questions) */}
⋮----
// Clear the code output in the codeViewState
⋮----
{/* Navigation Confirmation Dialog */}
⋮----
{/* Exam Submission Confirmation Dialog */}
⋮----
{/* Mobile view floating button */}
⋮----
{/* Semi-transparent overlay when menu is open */}
⋮----
{/* Mobile view menu */}
⋮----
{/* Question Only Button */}
⋮----
{/* Chat Only Button */}
⋮----
{/* Split View Button */}

================
File: src/components/LearnerScorecard.tsx
================
import React, { useState } from 'react';
import { ScorecardItem } from '../types/quiz';
⋮----
export interface LearnerScorecardProps {
    scorecard: ScorecardItem[];
    className?: string;
}
⋮----
// Calculate overall score as a percentage
⋮----
const toggleExpand = (index: number) =>
⋮----
{/* Summary card */}
⋮----
{/* Overall score */}
⋮----
{/* Criteria overview */}
⋮----
{/* Detailed feedback section */}

================
File: src/components/LearningMaterialEditor.tsx
================
import { useEffect, useRef, useState, forwardRef, useImperativeHandle, useCallback } from "react";
⋮----
// Add import for date picker
import DatePicker from "react-datepicker";
⋮----
// Add custom styles for dark mode
⋮----
// Import the BlockNoteEditor component
import BlockNoteEditor from "./BlockNoteEditor";
import ConfirmationDialog from "./ConfirmationDialog";
import { TaskData } from "@/types";
import { safeLocalStorage } from "@/lib/utils/localStorage";
⋮----
// Add import for ChatView
import ChatView from "./ChatView";
import { ChatMessage } from "../types/quiz";
⋮----
// Add import for PublishConfirmationDialog
import PublishConfirmationDialog from "./PublishConfirmationDialog";
⋮----
// Define the editor handle with methods that can be called by parent components
export interface LearningMaterialEditorHandle {
    save: () => Promise<void>;
    cancel: () => void;
    hasContent: () => boolean;
    hasChanges: () => boolean;
}
⋮----
interface LearningMaterialEditorProps {
    onChange?: (content: any[]) => void;
    isDarkMode?: boolean;
    className?: string;
    readOnly?: boolean;
    viewOnly?: boolean;
    showPublishConfirmation?: boolean;
    onPublishConfirm?: () => void;
    onPublishCancel?: () => void;
    taskId?: string;
    userId?: string;
    onPublishSuccess?: (updatedData?: TaskData) => void;
    onSaveSuccess?: (updatedData?: TaskData) => void;
    scheduledPublishAt?: string | null;
}
⋮----
// Use forwardRef to pass the ref from parent to this component
⋮----
isDarkMode = true, // Default to dark mode
⋮----
// Reference to the editor instance
⋮----
// Add a ref to store the original data for reverting on cancel
⋮----
// Function to set the editor reference
const setEditorInstance = (editor: any) =>
⋮----
// Handle editor changes
const handleEditorChange = (content: any[]) =>
⋮----
// Avoid unnecessary state updates if content hasn't changed
⋮----
// Fetch task data when taskId changes
⋮----
// Use AbortController to cancel any in-flight requests
⋮----
// We only use the data fetched from our own API call
// Title updates only happen after publishing, not during editing
⋮----
// Store the original data for reverting on cancel
⋮----
// Initialize editorContent with the blocks from taskData
⋮----
// Ignore AbortError as it's expected when navigating away
⋮----
// Clean up function will abort the fetch if the component unmounts
// or if the effect runs again (i.e., taskId changes)
⋮----
// If no taskId is provided, set loading to false immediately
// so the component can render the editor
⋮----
// Handle cancel in edit mode - revert to original data
const handleCancel = () =>
⋮----
// Restore the original data
⋮----
// Return the original title to the dialog header
⋮----
const handleConfirmPublish = async (scheduledPublishAt: string | null) =>
⋮----
// Get the current title from the dialog - it may have been edited
⋮----
// Use the current editor content
⋮----
// Add scheduled publishing data if selected
⋮----
// Make POST request to publish the learning material content
⋮----
// Get the updated task data from the response
⋮----
// Ensure the status is set correctly based on scheduled status
⋮----
title: currentTitle,   // Use the current title from the dialog
scheduled_publish_at: scheduledPublishAt // Include scheduled date
⋮----
// Update our local state with the data from the API
⋮----
// First set publishing to false to avoid state updates during callbacks
⋮----
// Call the original onPublishConfirm callback if provided
⋮----
// Call the onPublishSuccess callback if provided
⋮----
// Use setTimeout to break the current render cycle
⋮----
const handleCancelPublish = () =>
⋮----
// Handle saving changes when in edit mode
const handleSave = async () =>
⋮----
// Get the current title from the dialog - it may have been edited
⋮----
// Use the current editor content
⋮----
// Use the scheduledPublishAt prop instead of taskData.scheduled_publish_at
⋮----
// Make POST request to update the learning material content, keeping the same status
⋮----
// Get the updated task data from the response
⋮----
// Create updated data with the current title
⋮----
title: currentTitle // Use the current title from the dialog
⋮----
// Update our local state with the data from the API
⋮----
// Call the onSaveSuccess callback if provided
⋮----
// Use setTimeout to break the current render cycle
⋮----
// Update the content when it changes
⋮----
// Expose methods via the forwarded ref
⋮----
// First check the editorContent state
const checkContent = (content: any[] | undefined) =>
⋮----
// Check if there are any blocks beyond the first default paragraph
⋮----
// If there's only one block, check if it has actual content
⋮----
// Use stringify to check if there's actual content
⋮----
// Check if it's not just an empty paragraph
⋮----
// First check editorContent (which might be updated if user made changes)
⋮----
// If editorContent is empty but we have taskData, check that as a fallback
⋮----
// If we don't have original data to compare with, assume no changes
⋮----
// Check if title has changed
⋮----
// Check if content has changed
⋮----
// Convert both to JSON strings for deep comparison
⋮----
// Return true if there are changes
⋮----
{/* Replace the ConfirmationDialog with PublishConfirmationDialog */}
⋮----
// Add display name for better debugging

================
File: src/components/LearningMaterialLinker.tsx
================
import { useState, useEffect, useRef } from "react";
import { FileText, X, Search, Plus } from "lucide-react";
⋮----
// Define the LearningMaterial interface
export interface LearningMaterial {
    id: number;
    title: string;
    type: string;
    status: string;
}
⋮----
// Define props for the component
export interface LearningMaterialLinkerProps {
    courseId: string;
    linkedMaterialIds: string[];
    readOnly?: boolean;
    onMaterialsChange: (linkedMaterialIds: string[]) => void;
}
⋮----
// State variables for learning material selection
⋮----
// Effect to handle clicks outside the dropdown
⋮----
function handleClickOutside(event: MouseEvent)
⋮----
// Fetch learning materials when component mounts or linkedMaterialIds change
⋮----
// When question changes, fetch linked materials if there are any linked IDs
⋮----
// Reset selections when there are no linked materials
⋮----
// Function to fetch learning materials
const fetchLearningMaterials = async () =>
⋮----
// Use the courseId from props
⋮----
// Filter to only include published learning materials
⋮----
// Filter out already selected materials
⋮----
// Function to fetch linked materials
const fetchLinkedMaterials = async () =>
⋮----
// Filter to get only the linked materials (convert string IDs to numbers for comparison)
⋮----
// Set available materials excluding the linked ones
⋮----
// Function to handle learning material search
const handleLearningMaterialSearch = (e: React.ChangeEvent<HTMLInputElement>) =>
⋮----
// Show all available materials that aren't already selected
⋮----
// Filter by title AND exclude already selected materials
⋮----
// Function to select a learning material
const selectLearningMaterial = (material: LearningMaterial) =>
⋮----
// Check if already selected
⋮----
return; // Already selected, do nothing
⋮----
// Add to selection
⋮----
// Remove from filtered materials immediately for better UX
⋮----
// Update parent component with the new IDs
⋮----
// Function to remove a learning material
const removeLearningMaterial = (materialId: number) =>
⋮----
// Find the material to remove
⋮----
// Remove from selection
⋮----
// Add back to filtered materials if it matches the current search
⋮----
// Update parent component with the new IDs
⋮----
// Function to toggle the dropdown
const toggleLearningMaterialDropdown = () =>
⋮----
// Fetch learning materials when opening the dropdown
⋮----
// Reset search query when opening the dropdown
⋮----
// Render the read-only view for linked materials
⋮----
// Render the editable view with dropdown
⋮----
onClick=
⋮----
{/* Add Close Button */}
⋮----
{/* Display selected learning materials */}
⋮----
e.stopPropagation();
removeLearningMaterial(material.id);
⋮----
// No learning materials available at all
⋮----
// All materials have been selected
⋮----
// No matches for search term
⋮----
{/* Display selected learning materials outside dropdown */}
⋮----
<span className="text-white text-sm font-light mr-2">{material.title}</span>
                                <button
onClick=
⋮----
// Conditional rendering based on readOnly prop

================
File: src/components/LearningMaterialViewer.tsx
================
import { useEffect, useRef, useState, useCallback } from "react";
import { MessageCircle, X, CheckCircle, HelpCircle, MoreVertical, Menu, MoreHorizontal, Settings, PlusCircle, ListChecks } from "lucide-react";
⋮----
// Add custom styles for dark mode
⋮----
// Import the BlockNoteEditor component
import BlockNoteEditor from "./BlockNoteEditor";
import { TaskData } from "@/types";
import { safeLocalStorage } from "@/lib/utils/localStorage";
⋮----
// Add import for ChatView
import ChatView from "./ChatView";
import { ChatMessage } from "../types/quiz";
⋮----
interface LearningMaterialViewerProps {
    taskId?: string;
    userId?: string;
    isDarkMode?: boolean;
    className?: string;
    readOnly?: boolean;
    viewOnly?: boolean;
    onMarkComplete?: () => void;
}
⋮----
// Add state for button animation
⋮----
// Check if user has clicked the button before
⋮----
// Add state for mobile menu
⋮----
// Add state for chat view
⋮----
// Add state to track viewport size
⋮----
// Add state for chat exit animation
⋮----
// Mobile view mode for responsive layout
⋮----
// Fetch task data when taskId changes
⋮----
// Use AbortController to cancel any in-flight requests
⋮----
// Ignore AbortError as it's expected when navigating away
⋮----
// Clean up function will abort the fetch if the component unmounts
// or if the effect runs again (i.e., taskId changes)
⋮----
// Check localStorage on component mount
⋮----
// Add effect to manage button animation
⋮----
// Start entrance animation
⋮----
// After entrance animation completes, only start pulse if user hasn't clicked before
⋮----
// Only show pulse animation if user hasn't clicked the button before
⋮----
// Function to toggle mobile menu
const toggleMobileMenu = () =>
⋮----
// If opening the menu, stop pulse animation and save to localStorage
⋮----
// If this is the first time clicking, save to localStorage
⋮----
// Add effect to handle clicks outside the mobile menu
⋮----
function handleClickOutside(event: MouseEvent)
⋮----
// Add effect to handle viewport size changes
⋮----
const checkMobileView = () =>
⋮----
// Initial check
⋮----
// Set up event listener for window resize
⋮----
// Clean up event listener
⋮----
// Handle chat input change
const handleChatInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) =>
⋮----
// Create a handle retry function to resubmit the last user message
const handleRetry = () =>
⋮----
// Find the last user message
⋮----
// Store the message content and type before modifying chat history
⋮----
// Filter the chat history to remove error messages and the last user message
⋮----
// Update the chat history state
⋮----
// Call handleChatSubmit with the filtered history
⋮----
// Handle chat submit
const handleChatSubmit = async (responseType: 'text' | 'code' = 'text', currentResponse?: string, currentChatHistory?: ChatMessage[]) =>
⋮----
// Use currentResponse if provided (for retry), otherwise use currentAnswer
⋮----
// Add user message to chat history
⋮----
// Use the updated chat history instead of relying on the chatHistory state
⋮----
// Only clear currentAnswer if we're not using an override
⋮----
// Set AI responding state
⋮----
// Prepare the request body
⋮----
// Make the API call
⋮----
// Get the response body as a readable stream
⋮----
// Create a unique ID for the AI message
⋮----
// Add initial empty AI message to chat history
⋮----
// Process the stream
⋮----
const processStream = async () =>
⋮----
// Decode the value to text
⋮----
// Split the text into chunks (assuming each chunk is a JSON object)
⋮----
// Process the response field if it exists
⋮----
// Replace content instead of accumulating it
⋮----
// Stop showing the animation
⋮----
// Update the AI message with the latest content
⋮----
// If we never received any feedback, also reset the AI responding state
⋮----
// Start processing the stream
⋮----
// Add error message to chat history
⋮----
// Reset states
⋮----
// Function to handle audio submission
const handleAudioSubmit = (audioBlob: Blob) =>
⋮----
// Function to handle viewing scorecard
const handleViewScorecard = (scorecard: any[]) =>
⋮----
// Handle ask doubt button click
const handleAskDoubt = () =>
⋮----
// For mobile view, start closing animation first
⋮----
// Wait for animation to complete before hiding chat
⋮----
}, 300); // Match this with animation duration
⋮----
// Apply CSS classes based on mode
⋮----
// Remove existing mode classes
⋮----
// Add current mode class
⋮----
{/* Add responsive styles */}
⋮----
{/* Content Container - Always rendered to avoid reloading */}
⋮----
onChange={() => { }} // Read-only, no changes
⋮----
{/* Chat Container - Only visible when showChatView is true */}
⋮----
{/* Floating button for desktop and mobile with different layouts */}
⋮----
{/* Floating action button - behavior changes based on screen size */}
⋮----
// For desktop view OR mobile view with no onMarkComplete, directly trigger handleAskDoubt
⋮----
// For desktop view direct click
⋮----
// Only toggle menu in mobile view when onMarkComplete exists
⋮----
{/* 
                                  In mobile view:
                                  - Show MessageCircle directly if onMarkComplete is not defined
                                  - Show ListChecks as toggle icon if onMarkComplete exists (representing task actions)
                                */}
⋮----
{/* Only show mobile menu overlay and options when onMarkComplete exists */}
⋮----
{/* Mobile menu - only shown on smaller screens and when onMarkComplete exists */}
⋮----
{/* Ask a doubt button */}
⋮----
{/* Mark as complete button */}

================
File: src/components/LearningStreak.tsx
================
import React, { useMemo } from "react";
⋮----
interface LearningStreakProps {
    streakDays: number;
    activeDays: string[]; // Days that are active in the streak (e.g., ['M', 'T', 'S_0', 'S_6'])
}
⋮----
activeDays: string[]; // Days that are active in the streak (e.g., ['M', 'T', 'S_0', 'S_6'])
⋮----
// Get current day in IST
⋮----
// Create a date in IST (UTC+5:30)
⋮----
const istOffset = 5.5 * 60 * 60 * 1000; // 5.5 hours in milliseconds
⋮----
return istDate.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
⋮----
// All days of week for reference
⋮----
// Reorder days to put current day in the middle (4th position)
⋮----
// Calculate days before and after to create a balanced view with current day in center
⋮----
// Add 3 days before the current day
⋮----
// Add current day
⋮----
// Add 3 days after the current day
⋮----
// List of energizing emojis
⋮----
// Generate a random emoji from the list if streak is at least 1 day
⋮----
// Function to check if a day is active based on index
const isDayActive = (index: number): boolean =>
⋮----
// If the day is in the future (after the current day at index 3), it should never be active
⋮----
// Get the identifier for this position

================
File: src/components/MobileDropdown.tsx
================
import React, { useEffect, useRef, ReactNode } from 'react';
import { X } from 'lucide-react';
⋮----
export interface DropdownOption<T = any> {
    id: string | number;
    label: ReactNode;
    value: T;
}
⋮----
interface MobileDropdownProps<T = any> {
    isOpen: boolean;
    onClose: () => void;
    title: string;
    options: DropdownOption<T>[];
    selectedId?: string | number;
    onSelect: (option: DropdownOption<T>) => void;
    className?: string;
    contentClassName?: string;
    titleClassName?: string;
    closeButtonClassName?: string;
    optionClassName?: string;
    selectedOptionClassName?: string;
    renderOption?: (option: DropdownOption<T>, isSelected: boolean) => ReactNode;
}
⋮----
// Handle animation when opening and closing
⋮----
// Trigger animation after a small delay to ensure render
⋮----
// Lock body scroll when dropdown is open
⋮----
// Cleanup
⋮----
// Return null if not open
⋮----
// Handle backdrop click
const handleBackdropClick = (e: React.MouseEvent) =>
⋮----
// Handle option selection
const handleOptionSelect = (option: DropdownOption<T>) =>
⋮----
// Check if an option is selected
const isOptionSelected = (option: DropdownOption<T>) =>
⋮----
onClick=
⋮----
{/* Spacer for bottom safety area */}

================
File: src/components/ModuleCompletionSound.tsx
================
import { useEffect, useRef } from 'react';
⋮----
interface ModuleCompletionSoundProps {
    play: boolean;
}
⋮----
export default function ModuleCompletionSound(
⋮----
// Create a more impressive victory sound using AudioContext
const createVictorySound = () =>
⋮----
// Function to create our oscillators
const createOscillator = (type: OscillatorType, frequency: number, delay: number, duration: number, gainValue: number) =>
⋮----
// First thumping bass sound
⋮----
// Second thumping bass sound (slightly higher pitch)
⋮----
// Victory melody notes
⋮----
// Add a final triumphant chord
createOscillator('sine', 400, 1.2, 0.5, 0.4); // Base note
createOscillator('sine', 500, 1.2, 0.5, 0.3); // Middle note
createOscillator('sine', 600, 1.2, 0.5, 0.3); // Top note
⋮----
// Play the sound when the play prop is true
⋮----
// No visual element to render

================
File: src/components/PublishConfirmationDialog.tsx
================
import { useState } from 'react';
import ConfirmationDialog from './ConfirmationDialog';
import DatePicker from "react-datepicker";
⋮----
interface PublishConfirmationDialogProps {
    show: boolean;
    onConfirm: (scheduledPublishAt: string | null) => void;
    onCancel: () => void;
    isLoading?: boolean;
    errorMessage?: string | null;
    title: string;
    message: string;
}
⋮----
// State for scheduling
⋮----
// Validate scheduled date
const verifyScheduledDateAndSchedulePublish = (date: Date | null) =>
⋮----
return; // Don't allow dates in the past
⋮----
// Reset scheduling state when dialog is closed
⋮----
// Handle confirmation with scheduling data
const handleConfirm = () =>
⋮----
// Render the scheduler UI
⋮----
setScheduleForLater(e.target.checked);
// Set default scheduled date to tomorrow at same time if nothing is set
⋮----
minDate={new Date()} // Can't schedule in the past

================
File: src/components/QuizEditor.tsx
================
import { useState, useEffect, useRef, useCallback, useMemo, forwardRef, useImperativeHandle } from "react";
import { ChevronLeft, ChevronRight, Plus, FileText, Trash2, FileCode, AudioLines, Check, HelpCircle, X, ChevronDown, Pen, ClipboardCheck, Search, BookOpen, Code, Sparkles, Tag } from "lucide-react";
⋮----
// Add custom styles for dark mode
⋮----
// Import the BlockNoteEditor component
import BlockNoteEditor from "./BlockNoteEditor";
// Import the LearnerQuizView component
import LearnerQuizView from "./LearnerQuizView";
import ConfirmationDialog from "./ConfirmationDialog";
// Import the new Dropdown component
import Dropdown, { DropdownOption } from "./Dropdown";
// Import the ScorecardPickerDialog component
import ScorecardPickerDialog, { CriterionData, ScorecardTemplate } from "./ScorecardPickerDialog";
// Import the new Scorecard component
import Scorecard, { ScorecardHandle } from "./Scorecard";
// Import dropdown options
import { questionTypeOptions, answerTypeOptions, codingLanguageOptions, questionPurposeOptions } from "./dropdownOptions";
// Import quiz types
import { QuizEditorHandle, QuizQuestionConfig, QuizQuestion, QuizEditorProps, APIQuestionResponse, ScorecardCriterion } from "../types";
// Add import for LearningMaterialLinker
import LearningMaterialLinker from "./LearningMaterialLinker";
// Import Toast component
import Toast from "./Toast";
// Import Tooltip component
import Tooltip from "./Tooltip";
// Import the PublishConfirmationDialog component
import PublishConfirmationDialog from './PublishConfirmationDialog';
import { useEditorContentOrSelectionChange } from "@blocknote/react";
⋮----
// Default configuration for new questions
⋮----
// Add these new interfaces after your existing interfaces
interface LearningMaterial {
    id: number;
    title: string;
    type: string;
    status: string;
}
⋮----
// Helper function to extract text from all blocks in a BlockNote document
export const extractTextFromBlocks = (blocks: any[]): string =>
⋮----
// Handle different block types
⋮----
// For paragraph blocks, extract text content
⋮----
// For heading blocks, extract text content
⋮----
// For list items, extract text content
⋮----
// For code blocks, extract text content from content array
⋮----
// Fallback for blocks with direct text property
⋮----
/**
 * Extracts and formats knowledge base content for API calls.
 * Validates that blocks contain actual content, not just empty structures.
 * 
 * @param {QuizQuestionConfig} config - The question configuration containing knowledge base data
 * @returns {Object|null} - Formatted knowledge base data for API or null if no valid content
 */
export const getKnowledgeBaseContent = (config: QuizQuestionConfig) =>
⋮----
// Check for knowledgeBaseBlocks
⋮----
// Extract text from blocks to check if they contain actual content
⋮----
// Check if there are any linked materials
⋮----
// If we have either valid blocks or linked materials, return the knowledge base data
⋮----
// If no valid knowledge base content, return null
⋮----
initialQuestions = [], // Not used anymore - kept for backward compatibility
⋮----
schoolId, // Add schoolId prop to access school scorecards
⋮----
// For published quizzes: data is always fetched from the API
// For draft quizzes: always start with empty questions
// initialQuestions prop is no longer used
⋮----
// Initialize questions state - always start with empty array
⋮----
// Store the original data for cancel functionality
⋮----
// Add a ref to store the original title
⋮----
// Add ref to store pending action when unsaved scorecard changes are detected
⋮----
// Add loading state for fetching questions
⋮----
// Track if data has been fetched to prevent infinite loops
⋮----
// Add state for school scorecards
⋮----
// Add loading state for fetching scorecards
⋮----
// Add state to track original scorecard data for change detection
⋮----
// Add ref to track if we're currently saving a scorecard
⋮----
// Add toast state
⋮----
// Add useEffect to automatically hide toast after 5 seconds
⋮----
// Cleanup the timer when component unmounts or showToast changes
⋮----
// Make sure we reset questions when component mounts for draft quizzes
⋮----
// Fetch school scorecards when component mounts for draft quizzes
⋮----
// Transform the API response to ScorecardTemplate format
⋮----
is_template: false, // Not a hard-coded template
new: scorecard.status === 'draft', // Not newly created in this session
⋮----
// Now that we have the scorecards, fetch the questions
⋮----
// If no scorecard data, fetch questions with empty scorecards
⋮----
// If no schoolId, just fetch questions with empty scorecards
⋮----
// Define the fetchQuestions function that takes scorecards as a parameter
⋮----
// Only fetch if we have a taskId, the status is published, and we haven't already fetched
⋮----
// Update the questions with the fetched data
⋮----
// Map API question type to local questionType
⋮----
// Use answer blocks directly from the API if available,
// otherwise create a default paragraph block
⋮----
// Handle scorecard data if scorecard_id is present
⋮----
// Find matching scorecard from school scorecards
⋮----
// Extract knowledgeBaseBlocks and linkedMaterialIds from context if it exists
⋮----
// Extract blocks for knowledge base if they exist
⋮----
// Extract linkedMaterialIds if they exist
⋮----
// Update questions state
⋮----
// Store original scorecard data for change detection
⋮----
// Store original data for all scorecards fetched from API (including draft ones)
⋮----
// Notify parent component about the update, but only once and after our state is updated
⋮----
// Use setTimeout to break the current render cycle
⋮----
// Store the original data for cancel operation
⋮----
// Mark that we've fetched the data - do this regardless of whether questions were found
⋮----
// Even on error, mark as fetched to prevent infinite retry loops
⋮----
// Reset hasFetchedData when taskId changes
⋮----
// Cleanup effect - clear questions when component unmounts or taskId changes
⋮----
// Return cleanup function
⋮----
// Clear questions state and refs when component unmounts
⋮----
// Store the original title when it changes in the dialog (for cancel operation)
⋮----
// Current question index
⋮----
// Internal state to track the current question ID for preview mode
⋮----
// Initialize with currentQuestionId if provided, otherwise use first question id if questions exist
⋮----
// Update current question index when currentQuestionId changes
⋮----
// Update activeQuestionId when currentQuestionIndex changes in preview mode
⋮----
// State to track if a new question was just added (for animation)
⋮----
// State for delete confirmation
⋮----
// Add state for scorecard delete confirmation
⋮----
// Add state to track if scorecard is used by multiple questions
⋮----
// Add state for scorecard save confirmation
⋮----
// State for tracking publishing status
⋮----
// State for tracking publishing errors
⋮----
// Reference to the current BlockNote editor instance
⋮----
// Use ref to track the last edit to prevent unnecessary updates
⋮----
// Reference to the correct answer editor
⋮----
// Reference to the knowledge base editor
⋮----
// State for scorecard templates dialog
⋮----
// We don't need the hasScorecard state anymore since we're using currentQuestionConfig.scorecardData
// If needed for the scorecard title, we'll keep that state
⋮----
// Reference to the scorecard component
⋮----
// State for tracking active tab (question or answer)
⋮----
// State to track which field is being highlighted for validation errors
⋮----
// State to track if the question count should be highlighted (after adding a new question)
⋮----
// Add validation utility functions to reduce duplication
// These functions can validate both the current question and any question by index
⋮----
/**
     * Highlights a field (question or answer) to draw attention to a validation error
     * @param field The field to highlight
     */
⋮----
// Set the highlighted field
⋮----
// Clear the highlight after 4 seconds
⋮----
/**
     * Validates if question content is non-empty
     * @param content The content blocks to validate
     * @returns True if content has non-empty text or contains media blocks, false otherwise
     */
⋮----
// Check for text content
⋮----
// If no text content, check if there are any media blocks (image, audio, video)
⋮----
/**
     * Validates if a question has a non-empty correct answer
     * @param questionConfig The question configuration containing the answer
     * @returns True if correct answer exists and is non-empty, false otherwise
     */
⋮----
/**
     * Validates if a question has a valid scorecard attached
     * @param questionConfig The question configuration containing the scorecard data
     * @returns True if a valid scorecard with criteria exists, false otherwise
     */
⋮----
/**
     * Validates scorecard criteria for empty names and descriptions
     * @param scorecard The scorecard data to validate
     * @param callbacks Object containing callback functions for validation actions
     * @returns True if all criteria are valid, false if any validation fails
     */
⋮----
questionIndex?: number; // Optional for showing question number in error message
⋮----
// If no scorecard or not a user-created scorecard (new), return true (valid)
⋮----
// Check each criterion for empty name or description
⋮----
// Check for empty name
⋮----
// Switch to scorecard tab first
⋮----
// Use a self-invoking function for delayed highlight and error message
⋮----
// Create event to highlight the problematic row
⋮----
// Show error message if callback is provided
⋮----
// Check for empty description
⋮----
// Switch to scorecard tab first
⋮----
// Use a self-invoking function for delayed highlight and error message
⋮----
// Create event to highlight the problematic row
⋮----
// Show error message if callback is provided
⋮----
// If all criteria passed validation
⋮----
/**
     * Validates all questions in the quiz and navigates to the first invalid question
     * @returns True if all questions are valid, false otherwise
     */
⋮----
// Check if there are any questions
⋮----
// Validate all questions
⋮----
// Check if question has content
⋮----
// Navigate to the question with missing content
⋮----
// Highlight the question field
⋮----
// Notify parent about validation error
⋮----
// For coding questions, check if coding languages are set
⋮----
// Navigate to the question with missing coding languages
⋮----
// Highlight the coding language field
⋮----
// Notify parent about validation error
⋮----
// For objective questions, check if correct answer is set
⋮----
// Navigate to the question with missing answer
⋮----
// Highlight the answer field
⋮----
// Notify parent about validation error
⋮----
// For subjective questions, check if scorecard is set
⋮----
// Navigate to the question with missing scorecard
⋮----
// Notify parent about validation error
⋮----
// Check for empty criterion names or descriptions in the scorecard
⋮----
// Navigate to the question with the problematic scorecard first
⋮----
// Use the shared validation function for scorecards
⋮----
// Function to handle opening the scorecard templates dialog
⋮----
// Approximate height of the dialog (templates + header)
⋮----
// Position the bottom of the dialog above the button with some spacing
⋮----
top: Math.max(10, schoolScorecards.length > 0 ? rect.top - estimatedDialogHeight - 80 : rect.top - estimatedDialogHeight - 10), // Ensure at least 10px from top of viewport
left: Math.max(10, rect.left - 120) // Center horizontally but ensure it's not off-screen
⋮----
// Add a reusable function for creating scorecards
⋮----
// Function to handle creating a new scorecard
const handleCreateNewScorecard = async () =>
⋮----
// Set the scorecard title
⋮----
// Use the reusable function to create scorecard
⋮----
// Create scorecard data using the backend ID
⋮----
id: createdScorecard.id, // Use the ID returned from backend
⋮----
new: true, // Mark as newly created in this session
is_template: false, // Not a template
⋮----
// Add the new scorecard to the question's config
⋮----
// Update school scorecards state with new scorecard
⋮----
// Add the new scorecard to originalScorecardData as the baseline for change detection
⋮----
// Switch to the scorecard tab
⋮----
// Focus on the scorecard title after a short delay to allow rendering
⋮----
// Show error toast
⋮----
// Function to handle selecting a scorecard template
const handleSelectScorecardTemplate = async (template: ScorecardTemplate) =>
⋮----
// Set the scorecard title
⋮----
// Creating from a hardcoded template - use the reusable function
⋮----
// Use the backend ID for the new scorecard
⋮----
id: createdScorecard.id, // Use the ID returned from backend
⋮----
// Update school scorecards state with new scorecard
⋮----
// Show error toast
⋮----
// one of the user generated scorecards - could be both published scorecards or newly created scorecards in this session itself
⋮----
// Add the new scorecard to originalScorecardData as the baseline for change detection
⋮----
// Add the scorecard data to the question's config
⋮----
// Switch to the scorecard tab
⋮----
// Focus on the scorecard title after a short delay to allow rendering
⋮----
// Function to set the editor reference
⋮----
// Memoize the current question content and config to prevent unnecessary re-renders
⋮----
// Function to set the correct answer editor reference
⋮----
// Function to set the knowledge base editor reference
⋮----
// Handle content change for the current question - use useCallback to memoize
⋮----
// Simply update the content without all the complexity
⋮----
// Update state
⋮----
// Call onChange callback if provided
⋮----
// Handle correct answer content change
⋮----
// Store blocks but don't extract text on every change
⋮----
// Handle configuration change for the current question
⋮----
// If updateTemplate flag is true and we have a newQuestionType, update the template content
⋮----
// Check if any block has an ID (indicating user modification)
⋮----
// Generate new template blocks based on the new question type
⋮----
// Update the content with the new template
⋮----
// Check if this scorecard is used by multiple questions
// const questionsUsingThisScorecard = questions.filter(q =>
//     q.config.scorecardData && q.config.scorecardData.id === scorecardForQuestion.id
// );
// const isUsedByMultiple = questionsUsingThisScorecard.length > 1;
⋮----
// if (isUsedByMultiple) {
// Only remove from current question without affecting others
⋮----
// }
// {
//     // Original behavior: remove from all questions and schoolScorecards if new
//     if (scorecardForQuestion && scorecardForQuestion.new) {
//         const updatedScorecards = schoolScorecards.filter(scorecard => scorecard.id !== scorecardForQuestion.id);
//         setSchoolScorecards(updatedScorecards);
//     }
⋮----
//     updatedQuestions = [...questions];
⋮----
//     for (let i = 0; i < updatedQuestions.length; i++) {
//         if (updatedQuestions[i].config.scorecardData && updatedQuestions[i].config.scorecardData?.id === scorecardForQuestion.id) {
//             updatedQuestions[i].config.scorecardData = undefined;
//         }
//     }
⋮----
//     setQuestions(updatedQuestions);
// }
⋮----
// Function to get template blocks based on question type
const getQuestionTemplateBlocks = (questionType: 'objective' | 'subjective', inputType: 'text' | 'code' | 'audio') =>
⋮----
// Common blocks that appear in all templates
⋮----
// Answer type section - not shown for coding questions
⋮----
// Programming languages section - only shown for coding questions
⋮----
// Tabs explanation - dependent on question type
⋮----
} else { // coding
⋮----
// Available block types (from learning material editor)
⋮----
// Writing effective questions section
⋮----
// Question type specific tips
⋮----
// Preview and publish explanation
⋮----
// Combine all blocks based on question type
⋮----
// Add a new question
⋮----
// Store the add question action as pending
⋮----
// Execute the add question logic without checking for unsaved changes
⋮----
// Extract the actual add question logic to a separate function
⋮----
// Get the previous question's configuration if available
// Otherwise, use default values
⋮----
// If there's at least one question (to be used as a reference)
⋮----
// Use the previous question's type
⋮----
// Use the previous question's input type (answer type)
⋮----
// Use the previous question's coding languages if available
⋮----
// Reset last content update ref
⋮----
// Trigger animation
⋮----
// Trigger question count highlight animation
⋮----
// Reset animation flags after animation completes
⋮----
}, 800); // slightly longer than animation duration to ensure it completes
⋮----
}, 1000); // Animation duration for the question counter highlight
⋮----
// Removed slash menu opening after adding a new question
⋮----
// Navigate to previous question
⋮----
// Store the previous question action as pending
⋮----
// Execute the previous question logic without checking for unsaved changes
⋮----
// Extract the actual previous question logic to a separate function
⋮----
// Reset last content update ref when navigating to a different question
⋮----
// Reset active tab to question when navigating
// Only change active tab if the current tab is not available in the next question
⋮----
// Call the onQuestionChange callback if provided
⋮----
// Navigate to next question
⋮----
// Store the next question action as pending
⋮----
// Execute the next question logic without checking for unsaved changes
⋮----
// Extract the actual next question logic to a separate function
⋮----
// Reset last content update ref when navigating to a different question
⋮----
// Reset active tab to question when navigating
⋮----
// Call the onQuestionChange callback if provided
⋮----
// Delete current question
⋮----
// If only one question, just clear the questions array
⋮----
// Adjust current index if necessary
⋮----
// Hide confirmation dialog
⋮----
// Reset last content update ref when deleting a question
⋮----
// Effect to initialize lastContentUpdateRef when changing questions
⋮----
// Placeholder component for empty quiz
⋮----
const updateDraftQuiz = async (scheduledPublishAt?: string | null, status: 'draft' | 'published' = 'published') =>
⋮----
// Get the current title from the dialog - it may have been edited
⋮----
// Format questions for the API
⋮----
// Map questionType to API type
⋮----
// Map inputType
⋮----
// Use our helper function to determine if this is an API scorecard
⋮----
// Return the formatted question object for all questions, not just those with scorecards
⋮----
// Make POST request to update the quiz
⋮----
// Get the updated task data from the response
⋮----
id: taskId // Ensure the ID is included for proper updating in the module list
⋮----
// Set publishing to false to avoid state updates during callbacks
⋮----
// Call the onPublishSuccess callback if provided
⋮----
// Use setTimeout to break the current render cycle
⋮----
// Modified handleSavePublishedQuiz for edit mode to send raw blocks of the correct answer
const handleSavePublishedQuiz = async () =>
⋮----
// Get the current title from the dialog - it may have been edited
⋮----
// Format questions for the API
⋮----
// Map questionType to API type
⋮----
// Get input_type from the current config
⋮----
// Use our helper function to determine if this is an API scorecard
⋮----
// Make PUT request to update the quiz content, keeping the same status
⋮----
// Get the updated task data from the response
⋮----
// Create updated data with the current title
⋮----
// Call the onSaveSuccess callback if provided
⋮----
// Handle cancel in edit mode - revert to original data
const handleCancel = () =>
⋮----
// Restore the original questions
⋮----
// Return the original title to the dialog header
⋮----
// Check if the current question has coding languages set
⋮----
return true; // Not relevant for non-coding questions
⋮----
// Check if coding languages array exists and has at least one value
⋮----
// Add function to check for unsaved scorecard changes across all questions
⋮----
// Check only the current question
⋮----
// Check if this question has a scorecard
⋮----
// If this is a new scorecard (not in original data), skip the check
⋮----
// Check if scorecard name has changed
⋮----
// Check if criteria have changed
⋮----
// Check if criteria length has changed
⋮----
// Check if any criterion has changed
⋮----
return false; // No unsaved changes found
⋮----
// Expose methods to parent component via the ref
⋮----
// Switch to question tab
⋮----
// Highlight the question field to draw attention to the error
⋮----
// Return null if there are no questions
⋮----
// Return the current question's type, defaulting to 'objective' if not set
⋮----
// Return null if there are no questions
⋮----
// Return the current question's input type, defaulting to 'text' if not set
⋮----
// Switch to answer tab
⋮----
// Highlight the answer field to draw attention to the error
⋮----
// Highlight the coding language field to draw attention to the error
⋮----
// Set the active editor tab
⋮----
// Return undefined if there are no questions
⋮----
// Return the current question's configuration
⋮----
// If we don't have original questions to compare with, assume no changes
⋮----
// Check if title has changed
⋮----
// Check if questions have changed (number, content, or configuration)
⋮----
// Convert both to JSON strings for deep comparison
⋮----
// Return true if there are changes
⋮----
// Update the MemoizedLearnerQuizView to include the correct answer
⋮----
// No validation checks - directly use the questions array
// Make a deep copy of questions
⋮----
// Update the current question with the latest correct answer blocks if possible
⋮----
// Find the index for this question ID
⋮----
// Update our internal state
⋮----
// Define dropdown options
// Now removed and imported from dropdownOptions.ts
⋮----
// Get dropdown option objects based on config values
⋮----
// Handle title change
⋮----
// Update the question config with the new question title
⋮----
// Handle question title input validation
⋮----
// Handle question title blur
⋮----
// Handle question title key down
⋮----
// Handle question type change
⋮----
// We know this is a single-select dropdown
⋮----
// Get the new question type
⋮----
// Update the question config with the new question type and also update template if needed
⋮----
// Set active tab to question whenever question type changes
⋮----
// Handle purpose change
⋮----
// We know this is a single-select dropdown
⋮----
// Get the new purpose
⋮----
// Update the question config with the new purpose
⋮----
// Handle answer type change
⋮----
// We know this is a single-select dropdown
⋮----
// Update the question config with the new input type
⋮----
// Handle coding language change
⋮----
// Cast to array since we know this is a multiselect dropdown
⋮----
// Define exclusive languages
⋮----
// Validation logic for language combinations
⋮----
// Find all exclusive languages in the selection
⋮----
// Check if any exclusive language is selected
⋮----
// If there are multiple exclusive languages, get the last one selected
⋮----
// If we have more than one language selected and at least one is exclusive,
// we need to filter out all other languages
⋮----
// Keep only the last exclusive language
⋮----
// Get a nice display name for the exclusive language
⋮----
// No exclusive languages, check for HTML and CSS combination
⋮----
// Find the HTML option in the coding language options
⋮----
// Add HTML to the validated options
⋮----
// Set the validated options
⋮----
// Update the question config with the validated options
⋮----
// Show feedback to the user if there was an invalid combination
⋮----
// Use setTimeout to ensure state is updated before showing the feedback
⋮----
// Show a toast notification
⋮----
// State for type dropdown
⋮----
// Update the selected options based on the current question's config
⋮----
// Set question type based on config
⋮----
// Set answer type based on config.inputType or default to 'text'
⋮----
// Set purpose based on config.purpose or default to 'practice'
⋮----
// Set coding languages based on config.codingLanguages or default to first option
⋮----
const isUserCreatedNewScorecard = (scorecardData: ScorecardTemplate): boolean =>
⋮----
const isLinkedScorecard = (scorecardData: ScorecardTemplate): boolean =>
⋮----
// New function to sync all questions with a source scorecard when it changes
⋮----
// Update all questions that have scorecard linked to this source
⋮----
// Check if this question has a linked scorecard with the matching id
⋮----
// Create an updated scorecard data
⋮----
// Return updated question with synced scorecard
⋮----
// Return question unchanged if it doesn't have a matching scorecard
⋮----
// Update questions state and notify parent
⋮----
// Function to handle saving published scorecard changes
⋮----
// Don't ask for confirmation if this is a new scorecard
⋮----
// Show confirmation dialog instead of saving directly
⋮----
// Function that actually performs the scorecard save operation
⋮----
// Only save if this is a published scorecard (not new)
// if (scorecardData.new) {
//     return;
// }
⋮----
// Prepare the scorecard data for the API
⋮----
// Make the API call to update the scorecard
⋮----
// Create the new original data immediately
⋮----
// Update the original scorecard data to reflect the saved state
⋮----
// Also update the ref immediately for synchronous access
// This ensures that any immediate checks will see the updated data
⋮----
// Show success toast if this is not a new scorecard
⋮----
// Show error toast
⋮----
// New function to handle complete scorecard revert
⋮----
return; // No original data to revert to
⋮----
// Create the reverted scorecard data
⋮----
// Update the question config atomically
⋮----
// Update the scorecard in schoolScorecards state
⋮----
// Sync all linked scorecards to reflect the reverted changes
⋮----
{/* Scorecard delete confirmation modal */}
⋮----
{/* Question delete confirmation modal */}
⋮----
{/* Scorecard save confirmation modal */}
⋮----
{/* Publish Confirmation Dialog */}
⋮----
{/* Loading indicator */}
⋮----
{/* Content area with animation when a new question is added */}
⋮----
onClick={(e) => e.stopPropagation()} // Stop events from bubbling up
onMouseDown={(e) => e.stopPropagation()} // Stop mousedown events too
⋮----
{/* Left Sidebar - Questions List */}
⋮----
{/* Sidebar Header */}
⋮----
{/* Add Question Button */}
⋮----
{/* Questions List */}
⋮----
if (checkUnsavedScorecardChanges())
⋮----
{/* Delete button - only show for current question and when not readonly */}
⋮----
e.stopPropagation();
setShowDeleteConfirm(true);
⋮----
{/* Main Content Area */}
⋮----
{/* Question Configuration Header */}
⋮----
{/* Segmented control for editor tabs */}
⋮----
{/* Editor Content */}
⋮----
{/* Show content based on active tab */}
⋮----
// Ensure the correct answer editor keeps focus
⋮----
// Try to focus the editor
⋮----
{/* Left column with callout (20-30% width) */}
⋮----
{/* Right column with linker and editor (70-80% width) */}
⋮----
{/* Add learning material selection component */}
⋮----
// Update the question config with the new linked material IDs
⋮----
// Ensure the knowledge base editor keeps focus
⋮----
// Try to focus the editor
⋮----
// Store blocks
⋮----
setQuestions(updatedQuestions);
⋮----
if (onChange)
onChange(updatedQuestions);
⋮----
// Scorecard tab - show empty table if scorecard is selected, otherwise show placeholder
⋮----
// Check if scorecard is used by multiple questions
⋮----
onDuplicate=
⋮----
// Use the reusable function to create duplicated scorecard
⋮----
// Create a duplicate scorecard with the backend ID
⋮----
id: createdScorecard.id, // Use the ID returned from backend
⋮----
new: true, // Mark as newly created to make it unlinked
⋮----
criteria: [...originalScorecard.criteria] // Deep copy the criteria
⋮----
// Update the current question to use the duplicated scorecard
⋮----
// Add the duplicated scorecard to school scorecards
⋮----
// Add the new scorecard to originalScorecardData as the baseline for change detection
⋮----
// Focus on the scorecard name for editing
⋮----
// Show error toast
⋮----
// Update the title of the current scorecard
⋮----
// Update the scorecard in schoolScorecards state
⋮----
// sync all linked scorecards to reflect the name change
⋮----
if (!currentQuestionConfig.scorecardData)
⋮----
// Update the current question's scorecard
⋮----
// Update the scorecard in schoolScorecards state
⋮----
// sync all linked scorecards to reflect the criteria changes
⋮----
{/* Scorecard Templates Dialog */}
⋮----
{/* Toast for language combination validation */}

================
File: src/components/SchoolPickerDialog.tsx
================
import React from 'react';
import { X } from 'lucide-react';
⋮----
interface School {
    id: string;
    name: string;
    role?: string;
    description?: string;
    createdAt?: string;
    updatedAt?: string;
    url?: string;
    slug?: string;
}
⋮----
interface SchoolPickerDialogProps {
    open: boolean;
    onClose: () => void;
    schools: School[];
    onSelectSchool: (schoolId: string) => void;
    onCreateSchool: () => void;
}
⋮----
// Check if user owns any schools
⋮----
{/* Dialog Header */}
⋮----
{/* Dialog Content */}
⋮----
{/* Dialog Footer */}

================
File: src/components/scorecard-styles.css
================
/* Styles for the editable scorecard title */
.editable-title:empty:before {
⋮----
.editable-title:focus {
⋮----
.editable-title {
⋮----
.scorecard-title-disabled:focus {

================
File: src/components/Scorecard.tsx
================
import React, { useRef, useEffect, forwardRef, useImperativeHandle, useState, useMemo } from 'react';
import { Trash2, Plus, X, Info, HelpCircle, Copy, RefreshCw, Save, Check } from 'lucide-react';
import { CriterionData } from './ScorecardPickerDialog';
import './scorecard-styles.css'; // We'll create this CSS file
import SimpleTooltip from './SimpleTooltip';
import Toast from './Toast'; // Import the Toast component
import Tooltip from './Tooltip'; // Import the Tooltip component
import { useEditorContentOrSelectionChange } from '@blocknote/react';
⋮----
interface ScorecardProps {
    name: string;
    criteria: CriterionData[];
    onDelete?: () => void;
    readOnly?: boolean;
    linked: boolean;
    onChange?: (criteria: CriterionData[]) => void;
    onNameChange?: (newName: string) => void;
    onDuplicate?: () => void; // New prop for duplicating the scorecard
    onSave?: () => void; // New prop for saving published scorecard changes
    new?: boolean; // New prop to indicate if the scorecard is new
    scorecardId?: string; // New prop for scorecard ID
    allQuestions?: any[]; // New prop to pass all questions for checking usage
    originalName?: string; // Original name for change detection
    originalCriteria?: CriterionData[]; // Original criteria for change detection
    onRevert?: () => void; // New prop for reverting all changes atomically
}
⋮----
onDuplicate?: () => void; // New prop for duplicating the scorecard
onSave?: () => void; // New prop for saving published scorecard changes
new?: boolean; // New prop to indicate if the scorecard is new
scorecardId?: string; // New prop for scorecard ID
allQuestions?: any[]; // New prop to pass all questions for checking usage
originalName?: string; // Original name for change detection
originalCriteria?: CriterionData[]; // Original criteria for change detection
onRevert?: () => void; // New prop for reverting all changes atomically
⋮----
export interface ScorecardHandle {
    focusName: () => void;
    discardChanges: () => void;
}
⋮----
// Interface to track which cell is being edited
interface EditingCell {
    rowIndex: number;
    field: 'name' | 'description' | 'maxScore' | 'minScore' | 'passScore';
}
⋮----
// State to track which cell is being edited
⋮----
// State to track the current value being edited
⋮----
// State to track name input value for controlled component
⋮----
// State for Toast notification
⋮----
// State to track highlighted fields
⋮----
// Add ref to track previous scorecard ID for transition detection
⋮----
// Update nameValue when prop changes
⋮----
// Listen for highlight-criterion events
⋮----
const handleHighlightCriterion = (event: CustomEvent) =>
⋮----
// Set the highlighted field - we only need the index now since we highlight the whole row
⋮----
// Clear the highlight after 4 seconds
⋮----
// Add event listener
⋮----
// Clean up
⋮----
// Auto-hide toast after 5 seconds
⋮----
}, 5000); // 5 seconds
⋮----
// Clean up timeout when component unmounts or toast state changes
⋮----
// Expose the focusName method to parent components
⋮----
// Select all text to make it easy to replace
⋮----
// Function to add a new criterion
const handleAddCriterion = () =>
⋮----
// Function to delete a criterion by index
const handleDeleteCriterion = (indexToDelete: number) =>
⋮----
// Function to close toast
const closeToast = () =>
⋮----
// Function to validate criteria before saving
const validateCriteriaForSave = () =>
⋮----
// Function to handle save with validation
const handleSave = () =>
⋮----
// Highlight the first problematic row
⋮----
// Show toast with validation error
⋮----
// Clear the highlight after 4 seconds
⋮----
return; // Don't proceed with save
⋮----
// If validation passes, proceed with save
⋮----
// Function to handle cancel - revert to original values
const handleCancel = () =>
⋮----
// Function to start editing a cell
const startEditing = (rowIndex: number, field: EditingCell['field']) =>
⋮----
// Function to save changes when editing is complete
const saveChanges = () =>
⋮----
// Convert to number and validate
⋮----
// Check for min/max score relationship
⋮----
// Show toast notification
⋮----
return; // Don't save the incorrect value
⋮----
// Show toast notification
⋮----
return; // Don't save the incorrect value
⋮----
// Show toast notification
⋮----
return; // Don't save the incorrect value
⋮----
// Handle key press events in the edit inputs
const handleKeyDown = (e: React.KeyboardEvent) =>
⋮----
// For descriptions, only save on Ctrl+Enter
⋮----
// Otherwise allow line breaks (default textarea behavior)
⋮----
// For other fields, save on Enter
⋮----
// Check if this scorecard is used by multiple questions
⋮----
// Count how many questions use this scorecard ID
⋮----
// Check if the scorecard has been modified (for published scorecards)
⋮----
// Detect if we're in a transition by comparing current and previous scorecard IDs
⋮----
// Update the ref for next comparison
⋮----
// Don't show changes during transitions to prevent save button flashing
⋮----
// For published scorecards with original data, check against original values
⋮----
// Check if name has changed
⋮----
// Check if criteria length has changed
⋮----
// Check if any criterion has changed
⋮----
if (!original) return true; // New criterion added
⋮----
// For draft scorecards (no original data), consider any content as changes
// Show save button if there's a name or any criteria with content
⋮----
// Determine if save button should be shown
⋮----
// Determine if banner should be shown
⋮----
{/* Toast notification */}
⋮----
{/* Header with name */}
⋮----
{/* NEW pill */}
{/* {isNew && (
                        <div className="mb-3">
                            <span className="inline-block px-2 py-1 rounded-full text-xs font-medium bg-green-700 text-white">
                                NEW
                            </span>
                        </div>
                    )} */}
⋮----
onChange=
⋮----
onNameChange(e.currentTarget.value);
⋮----
{/* Save scorecard button - only show for modified published scorecards */}
⋮----
{/* Cancel scorecard button - only show for modified published scorecards */}
⋮----
{/* Duplicate scorecard button - only show for linked scorecards */}
⋮----
{/* Delete scorecard button */}
⋮----
{/* Table header */}
⋮----
<div className="px-2"></div> {/* Empty header for delete button */}
⋮----
{/* Criteria rows */}
⋮----
// Generate a unique background color for each criterion pill
⋮----
// Check if this row should be highlighted
⋮----
{/* Criterion Name Cell */}
⋮----
{/* Description Cell */}
⋮----
{/* Min Score Cell */}
⋮----
{/* Max Score Cell */}
⋮----
{/* Pass Score Cell */}
⋮----
{/* Delete Button Cell */}
⋮----
{/* If no criteria, show empty state */}
⋮----
{/* Add Criterion button - now below the criteria rows */}
⋮----
// Add display name for better debugging

================
File: src/components/ScorecardPickerDialog.tsx
================
import React, { useState, useRef } from 'react';
import { X, Plus, Check, FileText, Mic } from 'lucide-react';
⋮----
export interface CriterionData {
    name: string;
    description: string;
    maxScore: number;
    minScore: number;
    passScore: number;
}
⋮----
interface Scorecard {
    id: string;
    name: string;
    status?: string;
    criteria: CriterionData[];
}
⋮----
export interface ScorecardTemplate extends Scorecard {
    icon?: React.ReactNode;
    description?: string;
    is_template?: boolean; // Identifies hard-coded templates
    new: boolean; // Identifies user-created scorecards in current session
}
⋮----
is_template?: boolean; // Identifies hard-coded templates
new: boolean; // Identifies user-created scorecards in current session
⋮----
interface ScorecardTemplatesDialogProps {
    isOpen: boolean;
    onClose: () => void;
    onCreateNew: () => void;
    onSelectTemplate: (template: ScorecardTemplate) => void;
    position?: { top: number; left: number };
    schoolScorecards?: ScorecardTemplate[]; // New prop for school-specific scorecards
}
⋮----
schoolScorecards?: ScorecardTemplate[]; // New prop for school-specific scorecards
⋮----
// Tab type for the dialog
type TabType = 'yours' | 'templates';
⋮----
// Preview component to show on hover - now matching the Issue Tracking design
⋮----
// Get the template-specific data or use defaults
const getStatusPills = () =>
⋮----
// Default status pills for other templates
⋮----
// Default criteria if not provided
⋮----
// Calculate position based on template position in the viewport
⋮----
// Default positioning
⋮----
const previewHeight = 350; // Approximate height of preview
⋮----
// Calculate available space below the template
⋮----
// Always position on the right side (outside the dialog)
⋮----
// If there's not enough space below, position from bottom up
⋮----
// Otherwise position from top down (default)
⋮----
{/* Header with name */}
⋮----
{/* Table header */}
⋮----
{/* Table rows */}
⋮----
// Generate a unique background color for each criterion pill
⋮----
{/* Description text - show for both standard and user types */}
⋮----
// Define template options with updated properties
⋮----
is_template: true, // This is a hard-coded template
⋮----
is_template: true, // This is a hard-coded template
⋮----
is_template: true, // This is a hard-coded template
⋮----
// {
//     id: 'written-communication2',
//     name: 'Written Communication',
//     icon: <Check size={16} className="text-white" />,
//     description: "Assess the quality of written communication",
//     criteria: [
//         { name: "Relevance", description: "How relevant is the content to the task?", maxScore: 5, passScore: 3 },
//         { name: "Grammar", description: "How grammatically correct is the content? Check for grammar, punctuation, syntax and tense errors.", maxScore: 5, passScore: 3 },
//         { name: "Clarity", description: "How clear is the content? Check for structure, organization, and readability.", maxScore: 5, passScore: 3 }
//     ]
// },
// {
//     id: 'interview-prep3',
//     name: 'Interview Preparation',
//     icon: <Sparkles size={16} className="text-white" />,
//     description: "Assess the quality of interviewing skills",
//     criteria: [
//         { name: "Relevance", description: "How relevant is the content to the question posed to them?", maxScore: 5, passScore: 3 },
//         { name: "Fluency", description: "How fluently does the candidate speak? Their pace should be neither slow nor fast but at a regular speaking speed. They should not use filler speech or pause frequently.", maxScore: 5, passScore: 3 },
//         { name: "Confidence", description: "How confident does the candidate sound? The tone should be confident and not hesitant. Check for nervous pauses or stutters.", maxScore: 5, passScore: 3 },
//         { name: "Pronunciation", description: "How well does the candidate pronounce the words? Their pronunciation should be clear and coherent. The words must be intelligible.", maxScore: 5, passScore: 3 }
//     ]
// },
⋮----
// Simpler approach: create a ref and track DOM element
⋮----
// Calculate position - default if not provided
⋮----
// Check if there are any school-specific scorecards to show
⋮----
// Tab navigation logic
⋮----
onClick=
⋮----
// Render your scorecards section with fixed height and scrollable
⋮----
// Filter scorecards based on search query
⋮----
{/* Search input for user scorecards */}
⋮----
onChange=
⋮----
{/* {template.new && (
                                    <span className="inline-flex items-center px-2 py-0.5 rounded-full text-[10px] font-medium bg-green-700 text-white ml-2">
                                        NEW
                                    </span>
                                )} */}
⋮----
{/* Preview positioned outside the scrollable container */}
⋮----
// Render templates section
⋮----
{/* Preview on hover */}
⋮----
{/* Header */}
⋮----
{/* Create new option */}
⋮----
{/* Tab navigation */}

⋮----
{/* Your Scorecards Tab Content */}
⋮----
{/* Templates Tab Content */}

================
File: src/components/ScorecardView.tsx
================
import React, { useState } from 'react';
import { ChevronLeft, ChevronDown, ChevronUp } from 'lucide-react';
import { ChatMessage, ScorecardItem } from '../types/quiz';
import LearnerScorecard from './LearnerScorecard';
⋮----
interface ScorecardViewProps {
    activeScorecard: ScorecardItem[];
    handleBackToChat: () => void;
    lastUserMessage: ChatMessage | null;
}
⋮----
const toggleTextExpansion = () =>

================
File: src/components/SettingsDialog.tsx
================
import React from 'react';
import { X, ExternalLink, Share } from 'lucide-react';
import Tooltip from './Tooltip';
import { DripConfig } from '@/types/course';
⋮----
interface SettingsDialogProps {
    isOpen: boolean;
    onClose: () => void;
    courseName: string;
    dripConfig: DripConfig;
    schoolId: string;
    courseId: number | undefined;
    cohortId: number | undefined;
    onCopyCohortInviteLink?: (cohortId: number, cohortName: string) => void;
}
⋮----
const getFrequencyText = () =>
⋮----
const formatDate = (date: Date) =>
⋮----
{/* Dialog Header */}
⋮----
{/* Course/Cohort Info */}
⋮----
{/* Release Schedule Section */}

================
File: src/components/SimpleTooltip.tsx
================
import React, { useState, ReactNode } from 'react';
⋮----
interface SimpleTooltipProps {
    children: ReactNode;
    text: string;
}

================
File: src/components/SuccessSound.tsx
================
import { useEffect, useRef } from 'react';
⋮----
interface SuccessSoundProps {
    play: boolean;
}
⋮----
export default function SuccessSound(
⋮----
// Create a short success sound using AudioContext
// This avoids the need for an external sound file
const createSuccessSound = () =>
⋮----
// Create an oscillator node for the sound
⋮----
oscillator.frequency.setValueAtTime(800, audioContext.currentTime); // Start at 800Hz
oscillator.frequency.exponentialRampToValueAtTime(1300, audioContext.currentTime + 0.1); // Ramp up to 1300Hz
oscillator.frequency.exponentialRampToValueAtTime(500, audioContext.currentTime + 0.3); // Then down to 500Hz
⋮----
// Create a gain node to control volume
⋮----
gainNode.gain.linearRampToValueAtTime(0.4, audioContext.currentTime + 0.05); // Fade in
gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.3); // Fade out
⋮----
// Connect nodes
⋮----
// Start and stop the oscillator
⋮----
// Play the sound when the play prop is true
⋮----
// No visual element to render

================
File: src/components/TaskTypeMetricCard.tsx
================
import React from "react";
⋮----
interface TaskTypeMetricCardProps {
    title: string;
    count: number;
    completionRate: number;
    color: "blue" | "purple" | "amber" | "teal" | "indigo";
}
⋮----
// Map color to the appropriate Tailwind CSS classes
⋮----
{/* Background completion indicator */}
⋮----
{/* task count container with fixed height */}
⋮----
{/* Progress bar */}

================
File: src/components/Toast.tsx
================
import React from 'react';
import { X } from 'lucide-react';
⋮----
interface ToastProps {
    show: boolean;
    title: string;
    description: string;
    emoji: string;
    onClose: () => void;
    isMobileView?: boolean;
}
⋮----
const Toast: React.FC<ToastProps> = ({
    show,
    title,
    description,
    emoji,
    onClose,
    isMobileView = false
}) =>

================
File: src/components/Tooltip.tsx
================
import { ReactNode, useState, useEffect, useRef } from "react";
⋮----
interface TooltipProps {
    children: ReactNode;
    content: string;
    position?: "top" | "bottom" | "left" | "right";
    delay?: number;
    disabled?: boolean;
    className?: string;
}
⋮----
const clearTimeouts = () =>
⋮----
// Clear timeout on unmount
⋮----
const showTip = () =>
⋮----
clearTimeouts(); // Clear any existing timeouts first
⋮----
const hideTip = () =>
⋮----
clearTimeouts(); // Clear the show timeout
⋮----
// Position-based classes for the tooltip
⋮----
// Arrow classes based on position

================
File: src/components/TopPerformers.tsx
================
import React, { useState, useEffect, useRef, useCallback } from "react";
import { createPortal } from "react-dom";
import Image from "next/image";
import { User, ChevronRight, ArrowRight, RefreshCcw } from "lucide-react";
import { useRouter } from "next/navigation";
import { useAuth } from "@/lib/auth";
⋮----
export interface Performer {
    name: string;
    streakDays: number;
    tasksSolved: number;
    position: number;
    userId?: number; // Optional user ID to identify the current user
}
⋮----
userId?: number; // Optional user ID to identify the current user
⋮----
interface TopPerformersProps {
    schoolId?: string; // School ID for navigation
    cohortId?: string; // Cohort ID for navigation
    view: 'learner' | 'admin';
    onEmptyData?: (isEmpty: boolean) => void; // Callback when data availability changes
}
⋮----
schoolId?: string; // School ID for navigation
cohortId?: string; // Cohort ID for navigation
⋮----
onEmptyData?: (isEmpty: boolean) => void; // Callback when data availability changes
⋮----
// State for data that will be fetched
⋮----
// Function to fetch performers data
⋮----
// Set the performers data
⋮----
position: index + 1, // Position based on array order
userId: stat.user.id // Keep track of user ID for identifying current user
⋮----
// const validPerformers = performersData.filter(performer => performer.streakDays > 0 || performer.tasksSolved > 0);
⋮----
// Get top performers but filter out those with 0 streak days
let topPerformers = validPerformers.slice(0, 3); // Take top 3 of those
⋮----
// Find current user in the FULL performers list (which will always include them)
⋮----
// Fetch data on mount and when cohortId changes
⋮----
// Update tooltip position based on button position
⋮----
top: rect.top - 10, // Position above the button with some spacing
left: rect.left + rect.width / 2, // Center horizontally
⋮----
// Function to get the appropriate badge SVG based on position
const getPositionBadge = (position: number) =>
⋮----
// Check if current user is already in top performers
⋮----
// Function to navigate to the full leaderboard
const navigateToLeaderboard = () =>
⋮----
// Function to handle refresh click with visual feedback
const handleRefresh = async (e: React.MouseEvent) =>
⋮----
e.stopPropagation(); // Prevent click from bubbling to parent elements
⋮----
// Reset refreshing state after a short delay to show animation
⋮----
// Create tooltip portal
⋮----
{/* Render tooltip via portal */}
⋮----
// Show top performers if list is not empty
⋮----
// Check if this performer is the current user
⋮----
src=
⋮----
// Show only current user with top performer styling when performers list is empty
⋮----
// No performers and no current user - show empty state
⋮----
{/* Show current user if they're not in top performers and performers list is not empty */}

================
File: src/components/UnauthorizedError.tsx
================
import React from 'react';
import { useRouter } from 'next/navigation';
import { EyeOff } from 'lucide-react';
⋮----
export default function UnauthorizedError()

================
File: src/context/EditorContext.tsx
================
import React, { createContext, useContext, useState, useCallback } from 'react';
⋮----
export type BlockType = 'paragraph' | 'heading' | 'bulletListItem' | 'numberedListItem' | 'checkListItem' | 'codeBlock' | 'video' | 'image' | 'audio';
⋮----
export interface Block {
    id: string;
    type: BlockType;
    content: string;
    indent?: number;
}
⋮----
interface EditorContextType {
    blocks: Block[];
    focusedBlockId: string | null;
    setFocusedBlockId: (id: string | null) => void;
    addBlock: (blockType: BlockType, afterId?: string, showMenu?: boolean) => string;
    updateBlockContent: (id: string, content: string) => void;
    updateBlockType: (id: string, type: BlockType) => void;
    deleteBlock: (id: string) => void;
    moveBlockUp: (id: string) => void;
    moveBlockDown: (id: string) => void;
    indentBlock: (id: string) => void;
    outdentBlock: (id: string) => void;
}
⋮----
export const useEditor = () =>
⋮----
const generateId = () => `block-$
⋮----
interface EditorProviderProps {
    children: React.ReactNode;
    initialBlocks?: Block[];
}
⋮----
export const EditorProvider: React.FC<EditorProviderProps> = ({
    children,
    initialBlocks = [{ id: generateId(), type: 'paragraph', content: '', indent: 0 }],
}) =>
⋮----
// Set focus to the new block
⋮----
// Don't allow deleting last block
⋮----
// Set focus to previous or next block

================
File: src/lib/utils/dateFormat.ts
================
/**
 * Formats a scheduled date for display in tooltips and buttons
 * @param date The date to format
 * @returns A human-readable string representation of the date
 */
export const formatScheduleDate = (date: Date | null): string =>
⋮----
// If the date is today, show "Today at [time]"
⋮----
// If the date is tomorrow, show "Tomorrow at [time]"
⋮----
// Otherwise, show the full date
⋮----
/**
 * Formats a date for full display in tooltips
 * @param date The date to format
 * @returns A detailed string representation of the date
 */
export const formatFullScheduleDate = (date: Date | null): string =>

================
File: src/lib/utils/localStorage.ts
================
// Safe localStorage wrapper to handle SSR and errors

================
File: src/lib/api.ts
================
import { useAuth } from "./auth";
import { useCallback, useEffect, useState } from 'react';
import { Task, Milestone } from "@/types";
import { Module } from "@/types/course";
import { transformMilestonesToModules } from "./course";
⋮----
// Define course interface based on your backend response
export interface Course {
  id: string;
  title: string;
  description?: string;
  coverImage?: string;
  createdAt?: string;
  updatedAt?: string;
  moduleCount?: number;
  role?: string;
  org?: {
    id: number;
    name: string;
    slug: string;
  };
  org_id?: number;
  // Add other fields as needed
}
⋮----
// Add other fields as needed
⋮----
// School interface (mapped from organization in the API)
export interface School {
  id: string;
  name: string;
  description?: string;
  createdAt?: string;
  updatedAt?: string;
  url?: string;
  role?: string;
  slug?: string;
  // Add other fields as needed
}
⋮----
// Add other fields as needed
⋮----
/**
 * Hook to fetch courses for the current user
 */
export function useCourses()
⋮----
// Fetch courses immediately when user ID is available
⋮----
// Simple fetch without caching
⋮----
// Transform the API response to match the expected format
⋮----
/**
 * Hook to fetch schools for the current user
 */
export function useSchools()
⋮----
// Fetch schools immediately when user ID is available
⋮----
// Simple fetch without caching
⋮----
// Transform the API response to match the expected format
⋮----
/**
 * Fetches and processes completion data for a user in a cohort
 * @param cohortId - The ID of the cohort
 * @param userId - The ID of the user
 * @returns Object containing task and question completion data
 */
export const getCompletionData = async (cohortId: number, userId: string): Promise<
⋮----
// Process completion data for tasks
⋮----
// Process completion data for questions
⋮----
// Iterate through each task in the completion data
⋮----
// Store task completion status
⋮----
// Store question completion status if questions exist
⋮----
/**
 * Fetches course data and transforms it into modules
 * @param courseId - The ID of the course
 * @param baseUrl - The base URL for the API request (defaults to NEXT_PUBLIC_BACKEND_URL)
 * @returns Object containing the course data and transformed modules
 * 
 * NOTE: This is a client-side function. For server components, use the version in server-api.ts
 */
export const getCourseModules = async (courseId: string, baseUrl?: string): Promise<
⋮----
// Determine which URL to use (server-side vs client-side)
⋮----
// Use the shared utility function to transform the milestones to modules
⋮----
export const addModule = async (courseId: string, schoolId: string, modules: Module[], setModules: (modules: Module[]) => void, setActiveModuleId: (moduleId: string) => void, lastUsedColorIndex: number, setLastUsedColorIndex: (colorIndex: number) => void) =>
⋮----
// Generate a diverse set of theme-compatible colors for dark mode
const getRandomPastelColor = () =>
⋮----
// Predefined set of diverse dark mode friendly colors in hex format
⋮----
'#2d3748',    // Slate blue
'#433c4c',    // Deep purple
'#4a5568',    // Cool gray
'#312e51',    // Indigo
'#364135',    // Forest green
'#4c393a',    // Burgundy
'#334155',    // Navy blue
'#553c2d',    // Rust brown
'#37303f',    // Plum
'#3c4b64',    // Steel blue
'#463c46',    // Mauve
'#3c322d',    // Coffee
⋮----
// Ensure we don't pick a color similar to the last one
⋮----
// If we have more than 6 colors, make sure the new color is at least 3 positions away
// from the last one to ensure greater visual distinction
⋮----
// Update the last used color index
⋮----
// Select a random color for the module
⋮----
// Make POST request to create a new milestone (module)
⋮----
color: backgroundColor, // Now sending color as hex with # symbol
⋮----
// Get the module ID from the response
⋮----
// Create the new module with the ID from the API
⋮----
id: data.id.toString(), // Convert to string to match our Module interface
⋮----
backgroundColor: `${backgroundColor}80`, // Add 50% opacity for UI display
⋮----
// Fallback to client-side ID generation if the API call fails
⋮----
backgroundColor: `${backgroundColor}80`, // Add 50% opacity for UI display

================
File: src/lib/auth.ts
================
import { useSession } from "next-auth/react";
import { useEffect, useState } from "react";
⋮----
// Global auth state outside React's lifecycle
// This ensures authentication is managed once per browser session
⋮----
// Type declarations are now in /src/types/next-auth.d.ts
⋮----
export const useAuth = () =>
⋮----
// Process session changes in an effect to control when it happens
⋮----
// Only process authenticated sessions
⋮----
// Log authentication exactly once per unique user ID
⋮----
// Update the state once
⋮----
interface GoogleUser {
  email: string;
  name?: string;
  given_name?: string;
  family_name?: string;
  image?: string;
  id?: string;
}
⋮----
interface AuthCredentials {
  user: GoogleUser;
  account: {
    access_token?: string;
    id_token?: string;
    provider?: string;
  };
}

================
File: src/lib/course.ts
================
import { Task, Milestone } from "@/types";
import { Module, ModuleItem } from "@/types/course";
⋮----
/**
 * Transforms course milestones to module format for consistent UI rendering
 * 
 * @param milestones - Array of course milestones with tasks
 * @returns Array of modules with their items
 */
export function transformMilestonesToModules(milestones: Milestone[] | undefined): Module[]
⋮----
// Map tasks to module items if they exist
⋮----
content: task.content || [], // Use content if available or empty array
⋮----
questions: task.questions || [], // Use questions if available or empty array
⋮----
// Sort items by position/ordering
⋮----
backgroundColor: `${milestone.color}80`, // Add 50% opacity for UI display
⋮----
// Sort modules by position/ordering
⋮----
// Set the first module to be expanded by default if modules exist
⋮----
/**
 * Transforms a course object with milestones to modules format
 * 
 * @param course - Course object with milestones array
 * @returns Array of modules
 */
⋮----
export function transformCourseToModules(course:

================
File: src/lib/server-api.ts
================
import { transformMilestonesToModules } from "./course";
⋮----
/**
 * Fetches course data and transforms it into modules (server-side version)
 * @param courseId - The ID of the course
 * @param baseUrl - The base URL for the API request
 * @returns Object containing the course data and transformed modules
 */
export const getPublishedCourseModules = async (courseId: string): Promise<
⋮----
// Use the shared utility function to transform the milestones to modules

================
File: src/lib/utils.ts
================
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";
⋮----
export function cn(...inputs: ClassValue[])

================
File: src/providers/SessionProvider.tsx
================
import { SessionProvider as NextAuthSessionProvider } from "next-auth/react";
import { ReactNode } from "react";
⋮----
interface SessionProviderProps {
    children: ReactNode;
}
⋮----
export function SessionProvider(

================
File: src/types/course.ts
================
import { QuizQuestion } from "./quiz";
export interface LearningMaterial {
  id: string;
  title: string;
  position: number;
  type: 'material';
  content?: any[]; // Using any[] for content blocks
  status?: string; // Add status field to track draft/published state
  scheduled_publish_at: string | null;
  isGenerating?: boolean;
}
⋮----
content?: any[]; // Using any[] for content blocks
status?: string; // Add status field to track draft/published state
⋮----
export interface Quiz {
  id: string;
  title: string;
  position: number;
  type: 'quiz';
  numQuestions?: number;
  questions: QuizQuestion[];
  status?: string; // Add status field to track draft/published state
  scheduled_publish_at: string | null;
  isGenerating?: boolean;
}
⋮----
status?: string; // Add status field to track draft/published state
⋮----
export type ModuleItem = LearningMaterial | Quiz;
⋮----
export interface Module {
  id: string;
  title: string;
  position: number;
  items: ModuleItem[];
  isExpanded?: boolean;
  backgroundColor?: string;
  isEditing?: boolean;
  progress?: number;
  unlockAt?: string;
}
⋮----
export interface CourseDetails {
  id: number | string;
  name: string;
  description?: string;
  modules?: Module[];
}
⋮----
export interface DripConfig {
    is_drip_enabled: boolean;
    frequency_value: number;
    frequency_unit: string;
    publish_at: Date | null;
}

================
File: src/types/index.ts
================
// Define interfaces for Task-related data
export interface TaskData {
    id: string;
    title: string;
    blocks: any[];
    status: string;
    scheduled_publish_at?: string;
}
⋮----
export interface Member {
    id: number;
    email: string;
}
⋮----
export interface CohortMember extends Member {
    role: 'learner' | 'mentor';
}
⋮----
export interface TeamMember extends Member {
    role: 'owner' | 'admin';  // Updated roles as per requirement
}
⋮----
role: 'owner' | 'admin';  // Updated roles as per requirement
⋮----
export interface Course {
    id: number;
    name: string;
}
⋮----
export interface Cohort {
    id: number;
    name: string;
    joined_at: string | undefined;
}
⋮----
export interface CohortWithDetails extends Cohort {
    members: CohortMember[];
    org_id: number;
    name: string;
    groups: any[];
    courses?: Course[];
}
⋮----
export interface Task {
    id: number;
    title: string;
    type: string;
    status: string;
    ordering: number;
    content?: any[]; // Content for learning materials
    num_questions?: number;
    questions?: any[]; // Questions for quizzes and exams
    scheduled_publish_at: string;
    is_generating: boolean;
}
⋮----
content?: any[]; // Content for learning materials
⋮----
questions?: any[]; // Questions for quizzes and exams
⋮----
export interface Milestone {
    id: number;
    name: string;
    color: string;
    ordering: number;
    tasks?: Task[];
    unlock_at?: string;
}
⋮----
// Export all quiz types
⋮----
// Export other types as needed

================
File: src/types/next-auth.d.ts
================
import { DefaultSession } from "next-auth";
⋮----
/**
   * Extend the built-in session types
   */
interface Session {
    user: {
      id: string;
    } & DefaultSession["user"];
  }

================
File: src/types/quiz.ts
================
import { CriterionData, ScorecardTemplate } from "../components/ScorecardPickerDialog";
⋮----
export interface QuizEditorHandle {
    saveDraft: () => Promise<void>;
    savePublished: () => Promise<void>;
    cancel: () => void;
    hasContent: () => boolean;
    hasChanges: () => boolean;
    hasQuestionContent: () => boolean;
    getCurrentQuestionType: () => 'objective' | 'subjective' | null;
    getCurrentQuestionInputType: () => 'text' | 'code' | 'audio' | null;
    hasCorrectAnswer: () => boolean;
    hasCodingLanguages: () => boolean;
    hasScorecard: () => boolean;
    setActiveTab: (tab: 'question' | 'answer' | 'scorecard' | 'knowledge') => void;
    validateBeforePublish: () => boolean;
    getCurrentQuestionConfig: () => QuizQuestionConfig | undefined;
    validateScorecardCriteria: (
        scorecard: ScorecardTemplate | undefined, 
        callbacks: {
            setActiveTab: (tab: 'question' | 'answer' | 'scorecard' | 'knowledge') => void;
            showErrorMessage?: (title: string, message: string, emoji?: string) => void;
            questionIndex?: number;
        }
    ) => boolean;
    hasUnsavedScorecardChanges: () => boolean;
    handleScorecardChangesRevert: () => void;
}
⋮----
export interface QuizQuestionConfig {
    inputType: 'text' | 'code' | 'audio';
    responseType: 'chat' | 'exam';
    correctAnswer?: any[];
    codingLanguages?: string[]; // For multiple coding languages
    audioMaxDuration?: number; // For audio input type in seconds
    questionType: 'objective' | 'subjective';
    scorecardData?: ScorecardTemplate;
    knowledgeBaseBlocks: any[]; // Add knowledge base content blocks
    linkedMaterialIds: string[]; // Add IDs of linked learning materials
    title: string;
}
⋮----
codingLanguages?: string[]; // For multiple coding languages
audioMaxDuration?: number; // For audio input type in seconds
⋮----
knowledgeBaseBlocks: any[]; // Add knowledge base content blocks
linkedMaterialIds: string[]; // Add IDs of linked learning materials
⋮----
export interface QuizQuestion {
    id: string;
    content: any[];
    config: QuizQuestionConfig;
}
⋮----
export interface QuizEditorProps {
    initialQuestions?: QuizQuestion[]; // Kept for backward compatibility but not used anymore
    onChange?: (questions: QuizQuestion[]) => void;
    isDarkMode?: boolean;
    className?: string;
    isPreviewMode?: boolean;
    readOnly?: boolean;
    onPublish?: () => void;
    taskId?: string;
    status?: string;
    onPublishSuccess?: (updatedData?: any) => void;
    showPublishConfirmation?: boolean;
    onPublishCancel?: () => void;
    isEditMode?: boolean;
    onSaveSuccess?: (updatedData?: any) => void;
    taskType?: 'quiz';
    currentQuestionId?: string;
    onQuestionChange?: (questionId: string) => void;
    onSubmitAnswer?: (questionId: string, answer: string) => void;
    userId?: string;
    schoolId?: string; // ID of the school for fetching school-specific scorecards
    onValidationError?: (message: string, description: string) => void; // Function to handle validation errors
    courseId?: string; // ID of the course for fetching learning materials
    scheduledPublishAt?: string | null;
    onQuestionChangeWithUnsavedScorecardChanges?: () => void;
}
⋮----
initialQuestions?: QuizQuestion[]; // Kept for backward compatibility but not used anymore
⋮----
schoolId?: string; // ID of the school for fetching school-specific scorecards
onValidationError?: (message: string, description: string) => void; // Function to handle validation errors
courseId?: string; // ID of the course for fetching learning materials
⋮----
export interface ScorecardCriterion {
    name: string;
    description: string;
    min_score: number;
    max_score: number;
    pass_score: number;
}
⋮----
// Define the API response question interface
export interface APIQuestionResponse {
    id: number;
    title: string;
    blocks: any[];
    answer?: string;
    type: string;
    input_type: string;
    response_type: string;
    scorecard_id?: number;
    scorecard?: {
        id: number;
        title: string;
        criteria: {
            id: number;
            name: string;
            description: string;
            min_score: number;
            max_score: number;
            pass_score: number
        }[];
    };
    context?: {
        blocks?: any[];
        linkedMaterialIds?: string[];
    };
    coding_languages?: string[];
}
⋮----
// Define a message type for the chat history
export interface ChatMessage {
    id: string;
    content: string;
    sender: 'user' | 'ai';
    timestamp: Date;
    messageType?: 'text' | 'audio' | 'code';
    audioData?: string; // base64 encoded audio data
    scorecard?: ScorecardItem[]; // Add scorecard field for detailed feedback
    isError?: boolean;
    is_correct?: boolean; // Add is_correct attribute for exam responses
}
⋮----
audioData?: string; // base64 encoded audio data
scorecard?: ScorecardItem[]; // Add scorecard field for detailed feedback
⋮----
is_correct?: boolean; // Add is_correct attribute for exam responses
⋮----
// Define scorecard item structure
export interface ScorecardItem {
    category: string;
    feedback: {
        correct: string;
        wrong: string;
    };
    score: number;
    max_score: number;
    pass_score: number
}
⋮----
export interface AIResponse {
    feedback: string;
    is_correct: boolean;
    scorecard?: ScorecardItem[];
}

================
File: src/index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;
⋮----
@layer base {
⋮----
:root {
⋮----
.dark {
⋮----
* {
⋮----
@apply border-border;
⋮----
body {
⋮----
/* Fix for text reversal issue */
.mirror-content {
⋮----
h1,
⋮----
h1 {
⋮----
@apply text-4xl;
⋮----
h2 {
⋮----
@apply text-3xl;
⋮----
h3 {
⋮----
@apply text-2xl;
⋮----
h4 {
⋮----
@apply text-xl;
⋮----
/* Editor specific styles */
.editor-block {
⋮----
.editor-block:hover .block-controls {
⋮----
@apply opacity-100;
⋮----
.editor-block .block-controls {
⋮----
.editor-block.focused {
⋮----
/* Placeholder styles */
[contenteditable="true"]:empty:before {
⋮----
/* Selection color */
::selection {

================
File: src/middleware.ts
================
import { NextResponse } from 'next/server'
import { getToken } from 'next-auth/jwt'
import { NextRequest } from 'next/server'
⋮----
export async function middleware(request: NextRequest)
⋮----
// Get session token
⋮----
// Define authentication paths
⋮----
// Public paths that don't require authentication
⋮----
// If the path is public, allow access
⋮----
// Redirect logic
⋮----
// Logged in users trying to access login page - redirect to home
⋮----
// Allow non-logged in users to access auth pages
⋮----
// Protect other routes - redirect to login if not authenticated
⋮----
// Create login URL with the correct base URL
⋮----
// Create callback URL with both pathname and search params from the original request
⋮----
// Copy all search params from the original request to the callback URL
⋮----
// Set the complete callback URL (with search params) as a parameter in the login URL
⋮----
// Configure which routes use this middleware
⋮----
/*
     * Match all request paths except for the ones starting with:
     * - api/auth (for NextAuth.js)
     * - _next/static (for static files)
     * - _next/image (for Next.js Image optimization)
     * - favicon.ico (for favicon)
     * - public folder
     */

================
File: .dockerignore
================
# Dependencies
node_modules
.pnp
.pnp.js

# Testing
/coverage

# Next.js
/.next/
/out/

# Production
/build

# Misc
.DS_Store
*.pem
.idea
.vscode

# Debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Local env files
.env*.local

# Logs
logs
*.log

# Version control
.git
.gitignore

# Docker
Dockerfile
.dockerignore

================
File: .env.example
================
# NextAuth Configuration
NEXTAUTH_URL=http://localhost:3000
NEXTAUTH_SECRET=your_nextauth_secret_here

# Google OAuth
GOOGLE_CLIENT_ID=your_google_client_id_here
GOOGLE_CLIENT_SECRET=your_google_client_secret_here

BACKEND_URL=http://localhost:8001
NEXT_PUBLIC_BACKEND_URL=http://localhost:8001
NEXT_PUBLIC_APP_URL=http://localhost:3000

JUDGE0_API_URL=LINK_TO_JUDGE0_API

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*
!.env.example

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# Jest
/coverage
/.jest/

# Keep jest results file for CI but don't track changes
/jest-results.json

# codecov
/codecov

================
File: .gitlab-ci.yml
================
image: node:20-alpine

# Define stages for the pipeline
stages:
  - test

workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main"
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_PIPELINE_SOURCE == "web"
    
# Cache dependencies to speed up builds
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - node_modules/

# Job for running tests and uploading coverage
variables:
  NEXT_TELEMETRY_DISABLED: "1"   # keep CI quiet

test-and-upload-coverage:
  stage: test
  script:
    # 0 — Install curl
    - apk add --no-cache curl
    
    # 1 — Install & test
    - npm ci
    - npm run test:coverage -- --maxWorkers=2

    # 2 — Download Codecov uploader (bash uploader is deprecated)
    - curl -Os https://cli.codecov.io/v10.4.0/alpine/codecov
    - chmod +x codecov

    # 3 — Upload the LCOV report
    - |
      # Pick the right variable for every pipeline type
      BRANCH_NAME="${CI_COMMIT_REF_NAME:-$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}"
    
      ./codecov upload-process -f coverage/lcov.info --git-service gitlab --branch "$BRANCH_NAME" --sha "$CI_COMMIT_SHA"
  artifacts:
    paths:
      - coverage/                     # lets you download the HTML report
    expire_in: 1 week

================
File: .repomixignore
================
# Ignore dependencies and build output
node_modules/
dist/
.next/
out/
coverage/
build/

# Ignore tests and public assets
test/
src/__tests__/
public/
eslint.config.mjs
jest.setup.js
jest.config.js
postcss.config.mjs
src/app/globals.css
repomix.config.json
tsconfig.jest.json
tsconfig.json

# Ignore config, temp, and local files
*.log
TODO*
.cursor/
*.local

================
File: codecov.yml
================
codecov:
  require_ci_to_pass: yes

coverage:
  precision: 2
  round: down
  range: "70...100"
  status:
    project:
      default:
        # Basic settings
        target: auto
        threshold: 1%
        base: auto
        # Advanced settings
        branches: null
        if_ci_failed: error
        only_pulls: false
        flags: null
        paths: null
    patch:
      default:
        # Basic settings
        target: auto
        threshold: 1%
        base: auto
        # Advanced settings
        branches: null
        if_ci_failed: error
        only_pulls: false
        flags: null
        paths: null

parsers:
  gcov:
    branch_detection:
      conditional: yes
      loop: yes
      method: no
      macro: no

comment:
  layout: "reach,diff,flags,files,footer"
  behavior: default
  require_changes: no
  require_base: no
  require_head: yes

ignore:
  - "**/*.stories.{js,jsx,ts,tsx}"
  - "**/*.d.ts"
  - "src/types/**/*"

================
File: docker-compose.dev.yml
================
services:
  frontend-dev:
    image: adalmia/sensai-frontend:dev
    ports:
      - "8502:3000"
    depends_on:
      backend-dev:
        condition: service_healthy
    # restart: unless-stopped
    networks:
      - sensai-network-dev

  backend-dev:
    image: adalmia/sensai-ai:v2-dev
    working_dir: /src
    command: bash -c "python /src/startup.py && uvicorn api.main:app --host 0.0.0.0 --port 8001"
    volumes:
      - /appdata_dev:/appdata
    ports:
      - "8002:8001"
    healthcheck:
      test: [ "CMD", "curl", "-f", "http://localhost:8001/health" ]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 10s
    networks:
      - sensai-network-dev

  public-api-dev:
    image: adalmia/sensai-ai:v2-dev
    working_dir: /src
    command: bash -c "python /src/startup.py && uvicorn api.public:app --host 0.0.0.0 --port 8001"
    volumes:
      - /appdata_dev:/appdata
    ports:
      - "8005:8001"

networks:
  sensai-network-dev:
    driver: bridge

================
File: docker-compose.prod.yml
================
services:
  frontend-prod:
    image: adalmia/sensai-frontend:latest
    ports:
      - "8501:3000"
    depends_on:
      backend-prod:
        condition: service_healthy
    # restart: unless-stopped
    networks:
      - sensai-network-prod

  backend-prod:
    image: adalmia/sensai-ai:latest
    working_dir: /src
    command: bash -c "python /src/startup.py && uvicorn api.main:app --host 0.0.0.0 --port 8001"
    volumes:
      - /appdata_prod:/appdata
    ports:
      - "8001:8001"
    healthcheck:
      test: [ "CMD", "curl", "-f", "http://localhost:8001/health" ]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 10s
    networks:
      - sensai-network-prod

  public-api-prod:
    image: adalmia/sensai-ai:latest
    working_dir: /src
    command: bash -c "python /src/startup.py && uvicorn api.public:app --host 0.0.0.0 --port 8001"
    volumes:
      - /appdata_prod:/appdata
    ports:
      - "8004:8001"

  phoenix:
    image: arizephoenix/phoenix:latest # Must be greater than 4.0 version to work
    ports:
      - 6006:6006 # PHOENIX_PORT
      - 4317:4317 # PHOENIX_GRPC_PORT
    environment:
      - PHOENIX_WORKING_DIR=/mnt/data
      - PHOENIX_ENABLE_AUTH=True
      - PHOENIX_SECRET=${PHOENIX_SECRET}
    volumes:
      - phoenix_data:/mnt/data # PHOENIX_WORKING_DIR

networks:
  sensai-network-prod:
    driver: bridge

volumes:
  phoenix_data:
    driver: local

================
File: Dockerfile
================
FROM node:22.12-alpine

# Set working directory
WORKDIR /app

# Define build arguments
ARG NODE_ENV
ARG NEXTAUTH_URL
ARG NEXTAUTH_SECRET
ARG BACKEND_URL
ARG NEXT_PUBLIC_BACKEND_URL
ARG JUDGE0_API_URL
ARG GOOGLE_CLIENT_ID
ARG GOOGLE_CLIENT_SECRET
ARG NEXT_PUBLIC_APP_URL

# Set environment variables
ENV NEXT_TELEMETRY_DISABLED=1
ENV NODE_ENV=${NODE_ENV}
ENV NEXTAUTH_URL=${NEXTAUTH_URL}
ENV NEXTAUTH_SECRET=${NEXTAUTH_SECRET}
ENV BACKEND_URL=${BACKEND_URL}
ENV GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}
ENV GOOGLE_CLIENT_SECRET=${GOOGLE_CLIENT_SECRET}
ENV NEXT_PUBLIC_BACKEND_URL=${NEXT_PUBLIC_BACKEND_URL}
ENV NEXT_PUBLIC_APP_URL=${NEXT_PUBLIC_APP_URL}
ENV JUDGE0_API_URL=${JUDGE0_API_URL}

# Copy package files and install dependencies
COPY package.json package-lock.json ./
RUN npm ci --include=dev

# Copy the rest of the application
COPY . .

# Build the application with environment variables available
RUN npm run build

# Expose the port the app runs on
EXPOSE 3000

# Start the application
CMD ["sh", "-c", "echo 'Environment variables:' && env | grep -E 'NEXTAUTH|GOOGLE|NODE_ENV|NEXT_PUBLIC|BACKEND|JUDGE0' && npm start"]

================
File: empty-module.ts
================


================
File: LICENSE
================
GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

  A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate.  Many developers of free software are heartened and
encouraged by the resulting cooperation.  However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

  The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community.  It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server.  Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

  An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals.  This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU Affero General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Remote Network Interaction; Use with the GNU General Public License.

  Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software.  This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU Affero General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) 2025  Aman Dalmia

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If your software can interact with users remotely through a computer
network, you should also make sure that it provides a way for users to
get its source.  For example, if your program is a web application, its
interface could display a "Source" link that leads users to an archive
of the code.  There are many ways you could offer source, and different
solutions will be better for different programs; see section 13 for the
specific requirements.

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU AGPL, see
<https://www.gnu.org/licenses/>.

================
File: next.config.ts
================
import type { NextConfig } from "next";
⋮----
/* config options here */
⋮----
// Warning: This allows production builds to successfully complete even if
// your project has ESLint errors.
⋮----
// Warning: This allows production builds to successfully complete even if
// your project has TypeScript errors.

================
File: package.json
================
{
  "name": "sensai",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "NEXT_TELEMETRY_DISABLED=1 next build",
    "start": "next start",
    "lint": "next lint",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:ci": "jest --ci --coverage --json --outputFile=jest-results.json"
  },
  "dependencies": {
    "@blocknote/core": "^0.24.2",
    "@blocknote/mantine": "^0.24.2",
    "@blocknote/react": "^0.24.2",
    "@headlessui/react": "^2.2.1",
    "@monaco-editor/react": "^4.7.0",
    "@radix-ui/react-avatar": "^1.1.3",
    "@radix-ui/react-dialog": "^1.1.6",
    "@radix-ui/react-dropdown-menu": "^2.1.6",
    "@radix-ui/react-slot": "^1.1.2",
    "@radix-ui/react-tabs": "^1.1.3",
    "@radix-ui/react-toast": "^1.2.6",
    "@types/canvas-confetti": "^1.9.0",
    "@types/lodash": "^4.17.16",
    "@types/react-datepicker": "^6.2.0",
    "autoprefixer": "^10.4.20",
    "canvas-confetti": "^1.9.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "codecov": "^3.8.2",
    "framer-motion": "^12.5.0",
    "lodash": "^4.17.21",
    "lucide-react": "^0.477.0",
    "next": "^15.2.3",
    "next-auth": "^4.24.11",
    "next-themes": "^0.4.4",
    "pdfjs-dist": "4.8.69",
    "react": "^19.0.0",
    "react-datepicker": "^8.3.0",
    "react-dom": "^19.0.0",
    "react-markdown": "^10.1.0",
    "react-pdf": "^9.2.1",
    "rehype-raw": "^7.0.0",
    "remark-gfm": "^4.0.1",
    "tailwind-merge": "^3.0.2",
    "tailwindcss-animate": "^1.0.7"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.3.0",
    "@types/jest": "^29.5.14",
    "@types/node": "^20",
    "@types/pdfjs-dist": "^2.10.377",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "camelcase": "^8.0.0",
    "eslint": "^9",
    "eslint-config-next": "15.2.0",
    "identity-obj-proxy": "^3.0.0",
    "jest": "^29.7.0",
    "jest-coverage-badges": "^1.1.2",
    "jest-environment-jsdom": "^29.7.0",
    "jest-transform-stub": "^2.0.0",
    "jest-watch-typeahead": "^2.2.2",
    "tailwind-scrollbar": "^4.0.1",
    "tailwindcss": "^4",
    "ts-jest": "^29.3.1",
    "typescript": "^5"
  }
}

================
File: README.md
================
## SensAI frontend

SensAI is an AI-first Learning Management System (LMS) which enables educators to help them teacher smarter and reach further. SensAI coaches your students through questions that develop deeper thinking—just like you would, but for every student and all the time. This repository is the frontend for SensAI. The backend repository can be found [here](https://gitlab.com/hvacademy/sensai-ai).

[![coverage report](https://codecov.io/gl/hvacademy/sensai-frontend/branch/main/graph/badge.svg)](https://codecov.io/gl/hvacademy/sensai-frontend)

If you are using SensAI and have any feedback for us or want any help with using SensAI, please consider [joining our community](https://chat.whatsapp.com/LmiulDbWpcXIgqNK6fZyxe) of AI + Education builders and reaching out to us.

If you want to contribute to SensAI, please look at the `Contributing` section [here](https://gitlab.com/hvacademy/sensai-ai/-/blob/main/docs/CONTRIBUTING.md).

Our public roadmap is live [here](https://hyperverge.notion.site/fa1dd0cef7194fa9bf95c28820dca57f?v=ec52c6a716e94df180dcc8ced3d87610). Go check it out and let us know what you think we should build next!

## Contributing
To learn more about making a contribution to SensAI, please see our [Contributing guide](https://gitlab.com/hvacademy/sensai-ai/-/blob/main/docs/CONTRIBUTING.md).

## Installation
- Make sure the backend is set up properly. Refer to the backend [installation guide](https://gitlab.com/hvacademy/sensai-ai/-/blob/main/docs/INSTALL.md) for more information.
- Ensure you have Node.js installed on your machine.
- Clone the repository:
  ```
  git clone https://gitlab.com/hvacademy/sensai-frontend.git
  cd sensai-frontend
  ```
- Copy `.env.example` to `.env.local` and set the environment variables. We use Judge0 for code execution. You will need to add the Judge0 API key to the `.env.local` file. Either self-host it or use the publicly available Judge0 instance. Please refer to the [Judge0 installation guide](https://gitlab.com/hvacademy/sensai-ai/-/blob/main/docs/INSTALL.md#judge0) for more information. Set up your Google OAuth account and enter those   credentials in the `.env.local` file.
- Install dependencies:
  ```
  npm ci
  ```
- Run the development server:
  ```
  npm run dev
  ```

The app will be available at `http://localhost:3000`.

## Testing

SensAI uses Jest and React Testing Library for testing. The test suite includes unit tests and component tests to ensure code quality and prevent regressions. Codecov is used to track the coverage of the tests.

- Run all tests (and generate a coverage report):
  ```
  npm run test:ci
  ```

- (optional) Upload the coverage report to Codecov:
  ```
  curl -Os https://cli.codecov.io/v10.4.0/macos/codecov
  chmod +x codecov
  ./codecov upload-process -f coverage/lcov.info
  ```


## Community
We are building a community of creators, builders, teachers, learners, parents, entrepreneurs, non-profits and volunteers who are excited about the future of AI and education. If you identify as one and want to be part of it, consider [joining our community](https://chat.whatsapp.com/LmiulDbWpcXIgqNK6fZyxe).

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */




================================================================
End of Codebase
================================================================
